# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -outcurrentdir -o geoda_proxy_wrap.cpp ../geoda_proxy.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_float_std__allocatorT_float_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_GeoDaProxy', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of VecFloat___nonzero__

`VecFloat___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat___nonzero__`, 'returnType') = 'logical'
attr(`VecFloat___nonzero__`, "inputTypes") = c('numeric')
class(`VecFloat___nonzero__`) = c("SWIGFunction", class('VecFloat___nonzero__'))

# Start of VecFloat___len__

`VecFloat___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat___len__`, 'returnType') = 'integer'
attr(`VecFloat___len__`, "inputTypes") = c('numeric')
class(`VecFloat___len__`) = c("SWIGFunction", class('VecFloat___len__'))

# Start of VecFloat_pop

`VecFloat_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_pop`, 'returnType') = 'numeric'
attr(`VecFloat_pop`, "inputTypes") = c('numeric')
class(`VecFloat_pop`) = c("SWIGFunction", class('VecFloat_pop'))

# Start of VecFloat___getslice__

`VecFloat___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecFloat___getslice__`, 'returnType') = 'numeric'
attr(`VecFloat___getslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___getslice__`) = c("SWIGFunction", class('VecFloat___getslice__'))

# Start of VecFloat___setslice__

`VecFloat___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecFloat___setslice__`, 'returnType') = 'void'
attr(`VecFloat___setslice__`, "inputTypes") = c('numeric', 'integer', 'integer', 'numeric')
class(`VecFloat___setslice__`) = c("SWIGFunction", class('VecFloat___setslice__'))

# Start of VecFloat___delslice__

`VecFloat___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecFloat___delslice__`, 'returnType') = 'void'
attr(`VecFloat___delslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___delslice__`) = c("SWIGFunction", class('VecFloat___delslice__'))

# Start of VecFloat___delitem__

`VecFloat___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecFloat___delitem__`, 'returnType') = 'void'
attr(`VecFloat___delitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___delitem__`) = c("SWIGFunction", class('VecFloat___delitem__'))

# Start of VecFloat___getitem__

`VecFloat___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat___getitem__`, 'returnType') = 'numeric'
attr(`VecFloat___getitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___getitem__`) = c("SWIGFunction", class('VecFloat___getitem__'))

# Start of VecFloat___setitem__

`VecFloat___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecFloat___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecFloat___setitem__`, 'returnType') = 'void'
attr(`VecFloat___setitem__`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat___setitem__`) = c("SWIGFunction", class('VecFloat___setitem__'))

# Start of VecFloat_append

`VecFloat_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_append', self, x, PACKAGE='geoda');
  
}

attr(`VecFloat_append`, 'returnType') = 'void'
attr(`VecFloat_append`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_append`) = c("SWIGFunction", class('VecFloat_append'))

# Start of new_VecFloat

`VecFloat__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecFloat__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecFloat__SWIG_0`, 'returnType') = 'numeric'
class(`VecFloat__SWIG_0`) = c("SWIGFunction", class('VecFloat__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_1` = function(s_arg1)
{
  s_arg1 = as.numeric(s_arg1);
  ;.Call('R_swig_new_VecFloat__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecFloat__SWIG_1`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_1`, "inputTypes") = c('numeric')
class(`VecFloat__SWIG_1`) = c("SWIGFunction", class('VecFloat__SWIG_1'))

# Start of VecFloat_empty

`VecFloat_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_empty`, 'returnType') = 'logical'
attr(`VecFloat_empty`, "inputTypes") = c('numeric')
class(`VecFloat_empty`) = c("SWIGFunction", class('VecFloat_empty'))

# Start of VecFloat_size

`VecFloat_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_size`, 'returnType') = 'integer'
attr(`VecFloat_size`, "inputTypes") = c('numeric')
class(`VecFloat_size`) = c("SWIGFunction", class('VecFloat_size'))

# Start of VecFloat_swap

`VecFloat_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecFloat_swap`, 'returnType') = 'void'
attr(`VecFloat_swap`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_swap`) = c("SWIGFunction", class('VecFloat_swap'))

# Start of VecFloat_clear

`VecFloat_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_clear', self, PACKAGE='geoda');
  
}

attr(`VecFloat_clear`, 'returnType') = 'void'
attr(`VecFloat_clear`, "inputTypes") = c('numeric')
class(`VecFloat_clear`) = c("SWIGFunction", class('VecFloat_clear'))

# Start of VecFloat_get_allocator

`VecFloat_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecFloat_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_float_t", ref=ans);
  
  ans
  
}

attr(`VecFloat_get_allocator`, 'returnType') = '_p_std__allocatorT_float_t'
attr(`VecFloat_get_allocator`, "inputTypes") = c('numeric')
class(`VecFloat_get_allocator`) = c("SWIGFunction", class('VecFloat_get_allocator'))

# Start of new_VecFloat

`VecFloat__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecFloat__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecFloat__SWIG_2`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_2`, "inputTypes") = c('integer')
class(`VecFloat__SWIG_2`) = c("SWIGFunction", class('VecFloat__SWIG_2'))

# Start of VecFloat_pop_back

`VecFloat_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecFloat_pop_back`, 'returnType') = 'void'
attr(`VecFloat_pop_back`, "inputTypes") = c('numeric')
class(`VecFloat_pop_back`) = c("SWIGFunction", class('VecFloat_pop_back'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecFloat_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecFloat_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_resize__SWIG_0`) = c("SWIGFunction", class('VecFloat_resize__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecFloat__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecFloat__SWIG_3`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecFloat__SWIG_3`) = c("SWIGFunction", class('VecFloat__SWIG_3'))

`VecFloat` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecFloat__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecFloat__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecFloat__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecFloat__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_push_back

`VecFloat_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecFloat_push_back`, 'returnType') = 'void'
attr(`VecFloat_push_back`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_push_back`) = c("SWIGFunction", class('VecFloat_push_back'))

# Start of VecFloat_front

`VecFloat_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_front`, 'returnType') = 'numeric'
attr(`VecFloat_front`, "inputTypes") = c('numeric')
class(`VecFloat_front`) = c("SWIGFunction", class('VecFloat_front'))

# Start of VecFloat_back

`VecFloat_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_back`, 'returnType') = 'numeric'
attr(`VecFloat_back`, "inputTypes") = c('numeric')
class(`VecFloat_back`) = c("SWIGFunction", class('VecFloat_back'))

# Start of VecFloat_assign

`VecFloat_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecFloat_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecFloat_assign`, 'returnType') = 'void'
attr(`VecFloat_assign`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_assign`) = c("SWIGFunction", class('VecFloat_assign'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecFloat_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecFloat_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_resize__SWIG_1`) = c("SWIGFunction", class('VecFloat_resize__SWIG_1'))

`VecFloat_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecFloat_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecFloat_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_reserve

`VecFloat_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecFloat_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecFloat_reserve`, 'returnType') = 'void'
attr(`VecFloat_reserve`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_reserve`) = c("SWIGFunction", class('VecFloat_reserve'))

# Start of VecFloat_capacity

`VecFloat_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecFloat_capacity`, 'returnType') = 'integer'
attr(`VecFloat_capacity`, "inputTypes") = c('numeric')
class(`VecFloat_capacity`) = c("SWIGFunction", class('VecFloat_capacity'))

# Start of delete_VecFloat

`delete_VecFloat` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecFloat', self, PACKAGE='geoda');
  
}

attr(`delete_VecFloat`, 'returnType') = 'void'
attr(`delete_VecFloat`, "inputTypes") = c('numeric')
class(`delete_VecFloat`) = c("SWIGFunction", class('delete_VecFloat'))

# Start of accessor method for std::vector<(float)>
setMethod('$', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecFloat___nonzero__, '__len__' = VecFloat___len__, 'pop' = VecFloat_pop, '__getslice__' = VecFloat___getslice__, '__setslice__' = VecFloat___setslice__, '__delslice__' = VecFloat___delslice__, '__delitem__' = VecFloat___delitem__, '__getitem__' = VecFloat___getitem__, '__setitem__' = VecFloat___setitem__, 'append' = VecFloat_append, 'empty' = VecFloat_empty, 'size' = VecFloat_size, 'swap' = VecFloat_swap, 'clear' = VecFloat_clear, 'get_allocator' = VecFloat_get_allocator, 'pop_back' = VecFloat_pop_back, 'resize' = VecFloat_resize, 'push_back' = VecFloat_push_back, 'front' = VecFloat_front, 'back' = VecFloat_back, 'assign' = VecFloat_assign, 'reserve' = VecFloat_reserve, 'capacity' = VecFloat_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(float)>
setMethod('delete', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(obj) {delete_std__vectorT_float_std__allocatorT_float_t_t(obj)})
# Start of VecString___nonzero__

`VecString___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString___nonzero__`, 'returnType') = 'logical'
attr(`VecString___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___nonzero__`) = c("SWIGFunction", class('VecString___nonzero__'))

# Start of VecString___len__

`VecString___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString___len__`, 'returnType') = 'integer'
attr(`VecString___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___len__`) = c("SWIGFunction", class('VecString___len__'))

# Start of VecString_pop

`VecString_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_pop`, 'returnType') = 'character'
attr(`VecString_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop`) = c("SWIGFunction", class('VecString_pop'))

# Start of VecString___getslice__

`VecString___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecString___getslice__', self, i, j, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`VecString___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___getslice__`) = c("SWIGFunction", class('VecString___getslice__'))

# Start of VecString___setslice__

`VecString___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecString___setslice__`, 'returnType') = 'void'
attr(`VecString___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___setslice__`) = c("SWIGFunction", class('VecString___setslice__'))

# Start of VecString___delslice__

`VecString___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecString___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecString___delslice__`, 'returnType') = 'void'
attr(`VecString___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___delslice__`) = c("SWIGFunction", class('VecString___delslice__'))

# Start of VecString___delitem__

`VecString___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecString___delitem__`, 'returnType') = 'void'
attr(`VecString___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___delitem__`) = c("SWIGFunction", class('VecString___delitem__'))

# Start of VecString___getitem__

`VecString___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString___getitem__`, 'returnType') = 'character'
attr(`VecString___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___getitem__`) = c("SWIGFunction", class('VecString___getitem__'))

# Start of VecString___setitem__

`VecString___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecString___setitem__`, 'returnType') = 'void'
attr(`VecString___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString___setitem__`) = c("SWIGFunction", class('VecString___setitem__'))

# Start of VecString_append

`VecString_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_append', self, x, PACKAGE='geoda');
  
}

attr(`VecString_append`, 'returnType') = 'void'
attr(`VecString_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_append`) = c("SWIGFunction", class('VecString_append'))

# Start of new_VecString

`VecString__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecString__SWIG_0', PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`VecString__SWIG_0`) = c("SWIGFunction", class('VecString__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_VecString__SWIG_1', s_arg1, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString__SWIG_1`) = c("SWIGFunction", class('VecString__SWIG_1'))

# Start of VecString_empty

`VecString_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_empty`, 'returnType') = 'logical'
attr(`VecString_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_empty`) = c("SWIGFunction", class('VecString_empty'))

# Start of VecString_size

`VecString_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_size`, 'returnType') = 'integer'
attr(`VecString_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_size`) = c("SWIGFunction", class('VecString_size'))

# Start of VecString_swap

`VecString_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecString_swap`, 'returnType') = 'void'
attr(`VecString_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_swap`) = c("SWIGFunction", class('VecString_swap'))

# Start of VecString_clear

`VecString_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_clear', self, PACKAGE='geoda');
  
}

attr(`VecString_clear`, 'returnType') = 'void'
attr(`VecString_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_clear`) = c("SWIGFunction", class('VecString_clear'))

# Start of VecString_get_allocator

`VecString_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecString_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`VecString_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`VecString_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_get_allocator`) = c("SWIGFunction", class('VecString_get_allocator'))

# Start of new_VecString

`VecString__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecString__SWIG_2', size, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_2`, "inputTypes") = c('integer')
class(`VecString__SWIG_2`) = c("SWIGFunction", class('VecString__SWIG_2'))

# Start of VecString_pop_back

`VecString_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecString_pop_back`, 'returnType') = 'void'
attr(`VecString_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop_back`) = c("SWIGFunction", class('VecString_pop_back'))

# Start of VecString_resize

`VecString_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecString_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecString_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_resize__SWIG_0`) = c("SWIGFunction", class('VecString_resize__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_VecString__SWIG_3', size, value, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`VecString__SWIG_3`) = c("SWIGFunction", class('VecString__SWIG_3'))

`VecString` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecString__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecString__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- VecString__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecString__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecString with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_push_back

`VecString_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecString_push_back`, 'returnType') = 'void'
attr(`VecString_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_push_back`) = c("SWIGFunction", class('VecString_push_back'))

# Start of VecString_front

`VecString_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_front`, 'returnType') = 'character'
attr(`VecString_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_front`) = c("SWIGFunction", class('VecString_front'))

# Start of VecString_back

`VecString_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_back`, 'returnType') = 'character'
attr(`VecString_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_back`) = c("SWIGFunction", class('VecString_back'))

# Start of VecString_assign

`VecString_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecString_assign`, 'returnType') = 'void'
attr(`VecString_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_assign`) = c("SWIGFunction", class('VecString_assign'))

# Start of VecString_resize

`VecString_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecString_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_resize__SWIG_1`) = c("SWIGFunction", class('VecString_resize__SWIG_1'))

`VecString_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecString_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecString_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecString_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_reserve

`VecString_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecString_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecString_reserve`, 'returnType') = 'void'
attr(`VecString_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_reserve`) = c("SWIGFunction", class('VecString_reserve'))

# Start of VecString_capacity

`VecString_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecString_capacity`, 'returnType') = 'integer'
attr(`VecString_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_capacity`) = c("SWIGFunction", class('VecString_capacity'))

# Start of delete_VecString

`delete_VecString` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecString', self, PACKAGE='geoda');
  
}

attr(`delete_VecString`, 'returnType') = 'void'
attr(`delete_VecString`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_VecString`) = c("SWIGFunction", class('delete_VecString'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecString___nonzero__, '__len__' = VecString___len__, 'pop' = VecString_pop, '__getslice__' = VecString___getslice__, '__setslice__' = VecString___setslice__, '__delslice__' = VecString___delslice__, '__delitem__' = VecString___delitem__, '__getitem__' = VecString___getitem__, '__setitem__' = VecString___setitem__, 'append' = VecString_append, 'empty' = VecString_empty, 'size' = VecString_size, 'swap' = VecString_swap, 'clear' = VecString_clear, 'get_allocator' = VecString_get_allocator, 'pop_back' = VecString_pop_back, 'resize' = VecString_resize, 'push_back' = VecString_push_back, 'front' = VecString_front, 'back' = VecString_back, 'assign' = VecString_assign, 'reserve' = VecString_reserve, 'capacity' = VecString_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of VecDouble___nonzero__

`VecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecDouble___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___nonzero__`) = c("SWIGFunction", class('VecDouble___nonzero__'))

# Start of VecDouble___len__

`VecDouble___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble___len__`, 'returnType') = 'integer'
attr(`VecDouble___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___len__`) = c("SWIGFunction", class('VecDouble___len__'))

# Start of VecDouble_pop

`VecDouble_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_pop`, 'returnType') = 'numeric'
attr(`VecDouble_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop`) = c("SWIGFunction", class('VecDouble_pop'))

# Start of VecDouble___getslice__

`VecDouble___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecDouble___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___getslice__`) = c("SWIGFunction", class('VecDouble___getslice__'))

# Start of VecDouble___setslice__

`VecDouble___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecDouble___setslice__`, 'returnType') = 'void'
attr(`VecDouble___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___setslice__`) = c("SWIGFunction", class('VecDouble___setslice__'))

# Start of VecDouble___delslice__

`VecDouble___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecDouble___delslice__`, 'returnType') = 'void'
attr(`VecDouble___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___delslice__`) = c("SWIGFunction", class('VecDouble___delslice__'))

# Start of VecDouble___delitem__

`VecDouble___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecDouble___delitem__`, 'returnType') = 'void'
attr(`VecDouble___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___delitem__`) = c("SWIGFunction", class('VecDouble___delitem__'))

# Start of VecDouble___getitem__

`VecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble___getitem__`, 'returnType') = 'numeric'
attr(`VecDouble___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___getitem__`) = c("SWIGFunction", class('VecDouble___getitem__'))

# Start of VecDouble___setitem__

`VecDouble___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecDouble___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecDouble___setitem__`, 'returnType') = 'void'
attr(`VecDouble___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble___setitem__`) = c("SWIGFunction", class('VecDouble___setitem__'))

# Start of VecDouble_append

`VecDouble_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_append', self, x, PACKAGE='geoda');
  
}

attr(`VecDouble_append`, 'returnType') = 'void'
attr(`VecDouble_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_append`) = c("SWIGFunction", class('VecDouble_append'))

# Start of new_VecDouble

`VecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecDouble__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecDouble__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`VecDouble__SWIG_0`) = c("SWIGFunction", class('VecDouble__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_1` = function(s_arg1)
{
  s_arg1 = as.numeric(s_arg1);
  ;.Call('R_swig_new_VecDouble__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecDouble__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble__SWIG_1`) = c("SWIGFunction", class('VecDouble__SWIG_1'))

# Start of VecDouble_empty

`VecDouble_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_empty`, 'returnType') = 'logical'
attr(`VecDouble_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_empty`) = c("SWIGFunction", class('VecDouble_empty'))

# Start of VecDouble_size

`VecDouble_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_size`, 'returnType') = 'integer'
attr(`VecDouble_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_size`) = c("SWIGFunction", class('VecDouble_size'))

# Start of VecDouble_swap

`VecDouble_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecDouble_swap`, 'returnType') = 'void'
attr(`VecDouble_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_swap`) = c("SWIGFunction", class('VecDouble_swap'))

# Start of VecDouble_clear

`VecDouble_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_clear', self, PACKAGE='geoda');
  
}

attr(`VecDouble_clear`, 'returnType') = 'void'
attr(`VecDouble_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_clear`) = c("SWIGFunction", class('VecDouble_clear'))

# Start of VecDouble_get_allocator

`VecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecDouble_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`VecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`VecDouble_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_get_allocator`) = c("SWIGFunction", class('VecDouble_get_allocator'))

# Start of new_VecDouble

`VecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecDouble__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecDouble__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecDouble__SWIG_2`) = c("SWIGFunction", class('VecDouble__SWIG_2'))

# Start of VecDouble_pop_back

`VecDouble_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecDouble_pop_back`, 'returnType') = 'void'
attr(`VecDouble_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop_back`) = c("SWIGFunction", class('VecDouble_pop_back'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecDouble_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecDouble_resize__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecDouble__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecDouble__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecDouble__SWIG_3`) = c("SWIGFunction", class('VecDouble__SWIG_3'))

`VecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecDouble__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_push_back

`VecDouble_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecDouble_push_back`, 'returnType') = 'void'
attr(`VecDouble_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_push_back`) = c("SWIGFunction", class('VecDouble_push_back'))

# Start of VecDouble_front

`VecDouble_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_front`, 'returnType') = 'numeric'
attr(`VecDouble_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_front`) = c("SWIGFunction", class('VecDouble_front'))

# Start of VecDouble_back

`VecDouble_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_back`, 'returnType') = 'numeric'
attr(`VecDouble_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_back`) = c("SWIGFunction", class('VecDouble_back'))

# Start of VecDouble_assign

`VecDouble_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecDouble_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecDouble_assign`, 'returnType') = 'void'
attr(`VecDouble_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_assign`) = c("SWIGFunction", class('VecDouble_assign'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecDouble_resize__SWIG_1'))

`VecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_reserve

`VecDouble_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecDouble_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecDouble_reserve`, 'returnType') = 'void'
attr(`VecDouble_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_reserve`) = c("SWIGFunction", class('VecDouble_reserve'))

# Start of VecDouble_capacity

`VecDouble_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecDouble_capacity`, 'returnType') = 'integer'
attr(`VecDouble_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_capacity`) = c("SWIGFunction", class('VecDouble_capacity'))

# Start of delete_VecDouble

`delete_VecDouble` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecDouble', self, PACKAGE='geoda');
  
}

attr(`delete_VecDouble`, 'returnType') = 'void'
attr(`delete_VecDouble`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_VecDouble`) = c("SWIGFunction", class('delete_VecDouble'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecDouble___nonzero__, '__len__' = VecDouble___len__, 'pop' = VecDouble_pop, '__getslice__' = VecDouble___getslice__, '__setslice__' = VecDouble___setslice__, '__delslice__' = VecDouble___delslice__, '__delitem__' = VecDouble___delitem__, '__getitem__' = VecDouble___getitem__, '__setitem__' = VecDouble___setitem__, 'append' = VecDouble_append, 'empty' = VecDouble_empty, 'size' = VecDouble_size, 'swap' = VecDouble_swap, 'clear' = VecDouble_clear, 'get_allocator' = VecDouble_get_allocator, 'pop_back' = VecDouble_pop_back, 'resize' = VecDouble_resize, 'push_back' = VecDouble_push_back, 'front' = VecDouble_front, 'back' = VecDouble_back, 'assign' = VecDouble_assign, 'reserve' = VecDouble_reserve, 'capacity' = VecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of VecVecDouble___nonzero__

`VecVecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecVecDouble___nonzero__`, "inputTypes") = c('list')
class(`VecVecDouble___nonzero__`) = c("SWIGFunction", class('VecVecDouble___nonzero__'))

# Start of VecVecDouble___len__

`VecVecDouble___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble___len__`, 'returnType') = 'integer'
attr(`VecVecDouble___len__`, "inputTypes") = c('list')
class(`VecVecDouble___len__`) = c("SWIGFunction", class('VecVecDouble___len__'))

# Start of VecVecDouble_pop

`VecVecDouble_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_pop`, 'returnType') = 'numeric'
attr(`VecVecDouble_pop`, "inputTypes") = c('list')
class(`VecVecDouble_pop`) = c("SWIGFunction", class('VecVecDouble_pop'))

# Start of VecVecDouble___getslice__

`VecVecDouble___getslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecVecDouble___getslice__`, 'returnType') = 'list'
attr(`VecVecDouble___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___getslice__`) = c("SWIGFunction", class('VecVecDouble___getslice__'))

# Start of VecVecDouble___setslice__

`VecVecDouble___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecVecDouble___setslice__`, 'returnType') = 'void'
attr(`VecVecDouble___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecDouble___setslice__`) = c("SWIGFunction", class('VecVecDouble___setslice__'))

# Start of VecVecDouble___delslice__

`VecVecDouble___delslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecVecDouble___delslice__`, 'returnType') = 'void'
attr(`VecVecDouble___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___delslice__`) = c("SWIGFunction", class('VecVecDouble___delslice__'))

# Start of VecVecDouble___delitem__

`VecVecDouble___delitem__` = function(self, i)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecVecDouble___delitem__`, 'returnType') = 'void'
attr(`VecVecDouble___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___delitem__`) = c("SWIGFunction", class('VecVecDouble___delitem__'))

# Start of VecVecDouble___getitem__

`VecVecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble___getitem__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___getitem__`) = c("SWIGFunction", class('VecVecDouble___getitem__'))

# Start of VecVecDouble___setitem__

`VecVecDouble___setitem__` = function(self, i, x)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecVecDouble___setitem__`, 'returnType') = 'void'
attr(`VecVecDouble___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble___setitem__`) = c("SWIGFunction", class('VecVecDouble___setitem__'))

# Start of VecVecDouble_append

`VecVecDouble_append` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_append', self, x, PACKAGE='geoda');
  
}

attr(`VecVecDouble_append`, 'returnType') = 'void'
attr(`VecVecDouble_append`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_append`) = c("SWIGFunction", class('VecVecDouble_append'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecDouble__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecVecDouble__SWIG_0`, 'returnType') = 'list'
class(`VecVecDouble__SWIG_0`) = c("SWIGFunction", class('VecVecDouble__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_1` = function(s_arg1)
{
  s_arg1 = lapply(s_arg1, as.numeric);
  ;.Call('R_swig_new_VecVecDouble__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecVecDouble__SWIG_1`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_1`, "inputTypes") = c('list')
class(`VecVecDouble__SWIG_1`) = c("SWIGFunction", class('VecVecDouble__SWIG_1'))

# Start of VecVecDouble_empty

`VecVecDouble_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_empty`, 'returnType') = 'logical'
attr(`VecVecDouble_empty`, "inputTypes") = c('list')
class(`VecVecDouble_empty`) = c("SWIGFunction", class('VecVecDouble_empty'))

# Start of VecVecDouble_size

`VecVecDouble_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_size`, 'returnType') = 'integer'
attr(`VecVecDouble_size`, "inputTypes") = c('list')
class(`VecVecDouble_size`) = c("SWIGFunction", class('VecVecDouble_size'))

# Start of VecVecDouble_swap

`VecVecDouble_swap` = function(self, v)
{
  self = lapply(self, as.numeric);
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecVecDouble_swap`, 'returnType') = 'void'
attr(`VecVecDouble_swap`, "inputTypes") = c('list', 'list')
class(`VecVecDouble_swap`) = c("SWIGFunction", class('VecVecDouble_swap'))

# Start of VecVecDouble_clear

`VecVecDouble_clear` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_clear', self, PACKAGE='geoda');
  
}

attr(`VecVecDouble_clear`, 'returnType') = 'void'
attr(`VecVecDouble_clear`, "inputTypes") = c('list')
class(`VecVecDouble_clear`) = c("SWIGFunction", class('VecVecDouble_clear'))

# Start of VecVecDouble_get_allocator

`VecVecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;ans = .Call('R_swig_VecVecDouble_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`VecVecDouble_get_allocator`, "inputTypes") = c('list')
class(`VecVecDouble_get_allocator`) = c("SWIGFunction", class('VecVecDouble_get_allocator'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecDouble__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecVecDouble__SWIG_2`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecDouble__SWIG_2`) = c("SWIGFunction", class('VecVecDouble__SWIG_2'))

# Start of VecVecDouble_pop_back

`VecVecDouble_pop_back` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecVecDouble_pop_back`, 'returnType') = 'void'
attr(`VecVecDouble_pop_back`, "inputTypes") = c('list')
class(`VecVecDouble_pop_back`) = c("SWIGFunction", class('VecVecDouble_pop_back'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecDouble_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecVecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.numeric(value);
  ;.Call('R_swig_new_VecVecDouble__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecVecDouble__SWIG_3`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble__SWIG_3`) = c("SWIGFunction", class('VecVecDouble__SWIG_3'))

`VecVecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecDouble__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- VecVecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_push_back

`VecVecDouble_push_back` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecVecDouble_push_back`, 'returnType') = 'void'
attr(`VecVecDouble_push_back`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_push_back`) = c("SWIGFunction", class('VecVecDouble_push_back'))

# Start of VecVecDouble_front

`VecVecDouble_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_front`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_front`, "inputTypes") = c('list')
class(`VecVecDouble_front`) = c("SWIGFunction", class('VecVecDouble_front'))

# Start of VecVecDouble_back

`VecVecDouble_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_back`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_back`, "inputTypes") = c('list')
class(`VecVecDouble_back`) = c("SWIGFunction", class('VecVecDouble_back'))

# Start of VecVecDouble_assign

`VecVecDouble_assign` = function(self, n, x)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecVecDouble_assign`, 'returnType') = 'void'
attr(`VecVecDouble_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_assign`) = c("SWIGFunction", class('VecVecDouble_assign'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecVecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_1'))

`VecVecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) )) {
      f <- VecVecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_reserve

`VecVecDouble_reserve` = function(self, n)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecDouble_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecVecDouble_reserve`, 'returnType') = 'void'
attr(`VecVecDouble_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_reserve`) = c("SWIGFunction", class('VecVecDouble_reserve'))

# Start of VecVecDouble_capacity

`VecVecDouble_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecDouble_capacity`, 'returnType') = 'integer'
attr(`VecVecDouble_capacity`, "inputTypes") = c('list')
class(`VecVecDouble_capacity`) = c("SWIGFunction", class('VecVecDouble_capacity'))

# Start of delete_VecVecDouble

`delete_VecVecDouble` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_delete_VecVecDouble', self, PACKAGE='geoda');
  
}

attr(`delete_VecVecDouble`, 'returnType') = 'void'
attr(`delete_VecVecDouble`, "inputTypes") = c('list')
class(`delete_VecVecDouble`) = c("SWIGFunction", class('delete_VecVecDouble'))

# Start of accessor method for std::vector<(std::vector<(double)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecDouble___nonzero__, '__len__' = VecVecDouble___len__, 'pop' = VecVecDouble_pop, '__getslice__' = VecVecDouble___getslice__, '__setslice__' = VecVecDouble___setslice__, '__delslice__' = VecVecDouble___delslice__, '__delitem__' = VecVecDouble___delitem__, '__getitem__' = VecVecDouble___getitem__, '__setitem__' = VecVecDouble___setitem__, 'append' = VecVecDouble_append, 'empty' = VecVecDouble_empty, 'size' = VecVecDouble_size, 'swap' = VecVecDouble_swap, 'clear' = VecVecDouble_clear, 'get_allocator' = VecVecDouble_get_allocator, 'pop_back' = VecVecDouble_pop_back, 'resize' = VecVecDouble_resize, 'push_back' = VecVecDouble_push_back, 'front' = VecVecDouble_front, 'back' = VecVecDouble_back, 'assign' = VecVecDouble_assign, 'reserve' = VecVecDouble_reserve, 'capacity' = VecVecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(double)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t(obj)})
# Start of VecInt___nonzero__

`VecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecInt___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___nonzero__`) = c("SWIGFunction", class('VecInt___nonzero__'))

# Start of VecInt___len__

`VecInt___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt___len__`, 'returnType') = 'integer'
attr(`VecInt___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___len__`) = c("SWIGFunction", class('VecInt___len__'))

# Start of VecInt_pop

`VecInt_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_pop`, 'returnType') = 'integer'
attr(`VecInt_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop`) = c("SWIGFunction", class('VecInt_pop'))

# Start of VecInt___getslice__

`VecInt___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecInt___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___getslice__`) = c("SWIGFunction", class('VecInt___getslice__'))

# Start of VecInt___setslice__

`VecInt___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecInt___setslice__`, 'returnType') = 'void'
attr(`VecInt___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___setslice__`) = c("SWIGFunction", class('VecInt___setslice__'))

# Start of VecInt___delslice__

`VecInt___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecInt___delslice__`, 'returnType') = 'void'
attr(`VecInt___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___delslice__`) = c("SWIGFunction", class('VecInt___delslice__'))

# Start of VecInt___delitem__

`VecInt___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecInt___delitem__`, 'returnType') = 'void'
attr(`VecInt___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___delitem__`) = c("SWIGFunction", class('VecInt___delitem__'))

# Start of VecInt___getitem__

`VecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt___getitem__`, 'returnType') = 'integer'
attr(`VecInt___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___getitem__`) = c("SWIGFunction", class('VecInt___getitem__'))

# Start of VecInt___setitem__

`VecInt___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecInt___setitem__`, 'returnType') = 'void'
attr(`VecInt___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___setitem__`) = c("SWIGFunction", class('VecInt___setitem__'))

# Start of VecInt_append

`VecInt_append` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_append', self, x, PACKAGE='geoda');
  
}

attr(`VecInt_append`, 'returnType') = 'void'
attr(`VecInt_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_append`) = c("SWIGFunction", class('VecInt_append'))

# Start of new_VecInt

`VecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecInt__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`VecInt__SWIG_0`) = c("SWIGFunction", class('VecInt__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_1` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  ;.Call('R_swig_new_VecInt__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecInt__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt__SWIG_1`) = c("SWIGFunction", class('VecInt__SWIG_1'))

# Start of VecInt_empty

`VecInt_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_empty`, 'returnType') = 'logical'
attr(`VecInt_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_empty`) = c("SWIGFunction", class('VecInt_empty'))

# Start of VecInt_size

`VecInt_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_size`, 'returnType') = 'integer'
attr(`VecInt_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_size`) = c("SWIGFunction", class('VecInt_size'))

# Start of VecInt_swap

`VecInt_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecInt_swap`, 'returnType') = 'void'
attr(`VecInt_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_swap`) = c("SWIGFunction", class('VecInt_swap'))

# Start of VecInt_clear

`VecInt_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_clear', self, PACKAGE='geoda');
  
}

attr(`VecInt_clear`, 'returnType') = 'void'
attr(`VecInt_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_clear`) = c("SWIGFunction", class('VecInt_clear'))

# Start of VecInt_get_allocator

`VecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_int_t", ref=ans);
  
  ans
  
}

attr(`VecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`VecInt_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_get_allocator`) = c("SWIGFunction", class('VecInt_get_allocator'))

# Start of new_VecInt

`VecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecInt__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt__SWIG_2`) = c("SWIGFunction", class('VecInt__SWIG_2'))

# Start of VecInt_pop_back

`VecInt_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecInt_pop_back`, 'returnType') = 'void'
attr(`VecInt_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop_back`) = c("SWIGFunction", class('VecInt_pop_back'))

# Start of VecInt_resize

`VecInt_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecInt_resize__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecInt__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecInt__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecInt__SWIG_3`) = c("SWIGFunction", class('VecInt__SWIG_3'))

`VecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_push_back

`VecInt_push_back` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecInt_push_back`, 'returnType') = 'void'
attr(`VecInt_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_push_back`) = c("SWIGFunction", class('VecInt_push_back'))

# Start of VecInt_front

`VecInt_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_front`, 'returnType') = 'integer'
attr(`VecInt_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_front`) = c("SWIGFunction", class('VecInt_front'))

# Start of VecInt_back

`VecInt_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_back`, 'returnType') = 'integer'
attr(`VecInt_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_back`) = c("SWIGFunction", class('VecInt_back'))

# Start of VecInt_assign

`VecInt_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecInt_assign`, 'returnType') = 'void'
attr(`VecInt_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_assign`) = c("SWIGFunction", class('VecInt_assign'))

# Start of VecInt_resize

`VecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecInt_resize__SWIG_1'))

`VecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- VecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_reserve

`VecInt_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecInt_reserve`, 'returnType') = 'void'
attr(`VecInt_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_reserve`) = c("SWIGFunction", class('VecInt_reserve'))

# Start of VecInt_capacity

`VecInt_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecInt_capacity`, 'returnType') = 'integer'
attr(`VecInt_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_capacity`) = c("SWIGFunction", class('VecInt_capacity'))

# Start of delete_VecInt

`delete_VecInt` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt', self, PACKAGE='geoda');
  
}

attr(`delete_VecInt`, 'returnType') = 'void'
attr(`delete_VecInt`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_VecInt`) = c("SWIGFunction", class('delete_VecInt'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt___nonzero__, '__len__' = VecInt___len__, 'pop' = VecInt_pop, '__getslice__' = VecInt___getslice__, '__setslice__' = VecInt___setslice__, '__delslice__' = VecInt___delslice__, '__delitem__' = VecInt___delitem__, '__getitem__' = VecInt___getitem__, '__setitem__' = VecInt___setitem__, 'append' = VecInt_append, 'empty' = VecInt_empty, 'size' = VecInt_size, 'swap' = VecInt_swap, 'clear' = VecInt_clear, 'get_allocator' = VecInt_get_allocator, 'pop_back' = VecInt_pop_back, 'resize' = VecInt_resize, 'push_back' = VecInt_push_back, 'front' = VecInt_front, 'back' = VecInt_back, 'assign' = VecInt_assign, 'reserve' = VecInt_reserve, 'capacity' = VecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of VecVecInt___nonzero__

`VecVecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecVecInt___nonzero__`, "inputTypes") = c('list')
class(`VecVecInt___nonzero__`) = c("SWIGFunction", class('VecVecInt___nonzero__'))

# Start of VecVecInt___len__

`VecVecInt___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt___len__`, 'returnType') = 'integer'
attr(`VecVecInt___len__`, "inputTypes") = c('list')
class(`VecVecInt___len__`) = c("SWIGFunction", class('VecVecInt___len__'))

# Start of VecVecInt_pop

`VecVecInt_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_pop`, 'returnType') = 'integer'
attr(`VecVecInt_pop`, "inputTypes") = c('list')
class(`VecVecInt_pop`) = c("SWIGFunction", class('VecVecInt_pop'))

# Start of VecVecInt___getslice__

`VecVecInt___getslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecVecInt___getslice__`, 'returnType') = 'list'
attr(`VecVecInt___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___getslice__`) = c("SWIGFunction", class('VecVecInt___getslice__'))

# Start of VecVecInt___setslice__

`VecVecInt___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecVecInt___setslice__`, 'returnType') = 'void'
attr(`VecVecInt___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecInt___setslice__`) = c("SWIGFunction", class('VecVecInt___setslice__'))

# Start of VecVecInt___delslice__

`VecVecInt___delslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecVecInt___delslice__`, 'returnType') = 'void'
attr(`VecVecInt___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___delslice__`) = c("SWIGFunction", class('VecVecInt___delslice__'))

# Start of VecVecInt___delitem__

`VecVecInt___delitem__` = function(self, i)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecVecInt___delitem__`, 'returnType') = 'void'
attr(`VecVecInt___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___delitem__`) = c("SWIGFunction", class('VecVecInt___delitem__'))

# Start of VecVecInt___getitem__

`VecVecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt___getitem__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___getitem__`) = c("SWIGFunction", class('VecVecInt___getitem__'))

# Start of VecVecInt___setitem__

`VecVecInt___setitem__` = function(self, i, x)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecVecInt___setitem__`, 'returnType') = 'void'
attr(`VecVecInt___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt___setitem__`) = c("SWIGFunction", class('VecVecInt___setitem__'))

# Start of VecVecInt_append

`VecVecInt_append` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_append', self, x, PACKAGE='geoda');
  
}

attr(`VecVecInt_append`, 'returnType') = 'void'
attr(`VecVecInt_append`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_append`) = c("SWIGFunction", class('VecVecInt_append'))

# Start of new_VecVecInt

`VecVecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecInt__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecVecInt__SWIG_0`, 'returnType') = 'list'
class(`VecVecInt__SWIG_0`) = c("SWIGFunction", class('VecVecInt__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_1` = function(s_arg1)
{
  s_arg1 = lapply(s_arg1, as.integer);
  ;.Call('R_swig_new_VecVecInt__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecVecInt__SWIG_1`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_1`, "inputTypes") = c('list')
class(`VecVecInt__SWIG_1`) = c("SWIGFunction", class('VecVecInt__SWIG_1'))

# Start of VecVecInt_empty

`VecVecInt_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_empty`, 'returnType') = 'logical'
attr(`VecVecInt_empty`, "inputTypes") = c('list')
class(`VecVecInt_empty`) = c("SWIGFunction", class('VecVecInt_empty'))

# Start of VecVecInt_size

`VecVecInt_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_size`, 'returnType') = 'integer'
attr(`VecVecInt_size`, "inputTypes") = c('list')
class(`VecVecInt_size`) = c("SWIGFunction", class('VecVecInt_size'))

# Start of VecVecInt_swap

`VecVecInt_swap` = function(self, v)
{
  self = lapply(self, as.integer);
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecVecInt_swap`, 'returnType') = 'void'
attr(`VecVecInt_swap`, "inputTypes") = c('list', 'list')
class(`VecVecInt_swap`) = c("SWIGFunction", class('VecVecInt_swap'))

# Start of VecVecInt_clear

`VecVecInt_clear` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_clear', self, PACKAGE='geoda');
  
}

attr(`VecVecInt_clear`, 'returnType') = 'void'
attr(`VecVecInt_clear`, "inputTypes") = c('list')
class(`VecVecInt_clear`) = c("SWIGFunction", class('VecVecInt_clear'))

# Start of VecVecInt_get_allocator

`VecVecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;ans = .Call('R_swig_VecVecInt_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t'
attr(`VecVecInt_get_allocator`, "inputTypes") = c('list')
class(`VecVecInt_get_allocator`) = c("SWIGFunction", class('VecVecInt_get_allocator'))

# Start of new_VecVecInt

`VecVecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecInt__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecVecInt__SWIG_2`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecInt__SWIG_2`) = c("SWIGFunction", class('VecVecInt__SWIG_2'))

# Start of VecVecInt_pop_back

`VecVecInt_pop_back` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecVecInt_pop_back`, 'returnType') = 'void'
attr(`VecVecInt_pop_back`, "inputTypes") = c('list')
class(`VecVecInt_pop_back`) = c("SWIGFunction", class('VecVecInt_pop_back'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecInt_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecVecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecVecInt__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecVecInt__SWIG_3`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt__SWIG_3`) = c("SWIGFunction", class('VecVecInt__SWIG_3'))

`VecVecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecInt__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_push_back

`VecVecInt_push_back` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecVecInt_push_back`, 'returnType') = 'void'
attr(`VecVecInt_push_back`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_push_back`) = c("SWIGFunction", class('VecVecInt_push_back'))

# Start of VecVecInt_front

`VecVecInt_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_front`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_front`, "inputTypes") = c('list')
class(`VecVecInt_front`) = c("SWIGFunction", class('VecVecInt_front'))

# Start of VecVecInt_back

`VecVecInt_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_back`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_back`, "inputTypes") = c('list')
class(`VecVecInt_back`) = c("SWIGFunction", class('VecVecInt_back'))

# Start of VecVecInt_assign

`VecVecInt_assign` = function(self, n, x)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecVecInt_assign`, 'returnType') = 'void'
attr(`VecVecInt_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_assign`) = c("SWIGFunction", class('VecVecInt_assign'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecVecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_1'))

`VecVecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_reserve

`VecVecInt_reserve` = function(self, n)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecInt_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecVecInt_reserve`, 'returnType') = 'void'
attr(`VecVecInt_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_reserve`) = c("SWIGFunction", class('VecVecInt_reserve'))

# Start of VecVecInt_capacity

`VecVecInt_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecInt_capacity`, 'returnType') = 'integer'
attr(`VecVecInt_capacity`, "inputTypes") = c('list')
class(`VecVecInt_capacity`) = c("SWIGFunction", class('VecVecInt_capacity'))

# Start of delete_VecVecInt

`delete_VecVecInt` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_delete_VecVecInt', self, PACKAGE='geoda');
  
}

attr(`delete_VecVecInt`, 'returnType') = 'void'
attr(`delete_VecVecInt`, "inputTypes") = c('list')
class(`delete_VecVecInt`) = c("SWIGFunction", class('delete_VecVecInt'))

# Start of accessor method for std::vector<(std::vector<(int)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecInt___nonzero__, '__len__' = VecVecInt___len__, 'pop' = VecVecInt_pop, '__getslice__' = VecVecInt___getslice__, '__setslice__' = VecVecInt___setslice__, '__delslice__' = VecVecInt___delslice__, '__delitem__' = VecVecInt___delitem__, '__getitem__' = VecVecInt___getitem__, '__setitem__' = VecVecInt___setitem__, 'append' = VecVecInt_append, 'empty' = VecVecInt_empty, 'size' = VecVecInt_size, 'swap' = VecVecInt_swap, 'clear' = VecVecInt_clear, 'get_allocator' = VecVecInt_get_allocator, 'pop_back' = VecVecInt_pop_back, 'resize' = VecVecInt_resize, 'push_back' = VecVecInt_push_back, 'front' = VecVecInt_front, 'back' = VecVecInt_back, 'assign' = VecVecInt_assign, 'reserve' = VecVecInt_reserve, 'capacity' = VecVecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(int)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t(obj)})
# Start of VecUINT8___nonzero__

`VecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecUINT8___nonzero__`, "inputTypes") = c('integer')
class(`VecUINT8___nonzero__`) = c("SWIGFunction", class('VecUINT8___nonzero__'))

# Start of VecUINT8___len__

`VecUINT8___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8___len__`, 'returnType') = 'integer'
attr(`VecUINT8___len__`, "inputTypes") = c('integer')
class(`VecUINT8___len__`) = c("SWIGFunction", class('VecUINT8___len__'))

# Start of VecUINT8_pop

`VecUINT8_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_pop`, 'returnType') = 'integer'
attr(`VecUINT8_pop`, "inputTypes") = c('integer')
class(`VecUINT8_pop`) = c("SWIGFunction", class('VecUINT8_pop'))

# Start of VecUINT8___getslice__

`VecUINT8___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___getslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecUINT8___getslice__`, 'returnType') = 'integer'
attr(`VecUINT8___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___getslice__`) = c("SWIGFunction", class('VecUINT8___getslice__'))

# Start of VecUINT8___setslice__

`VecUINT8___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecUINT8___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecUINT8___setslice__`) = c("SWIGFunction", class('VecUINT8___setslice__'))

# Start of VecUINT8___delslice__

`VecUINT8___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecUINT8___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___delslice__`) = c("SWIGFunction", class('VecUINT8___delslice__'))

# Start of VecUINT8___delitem__

`VecUINT8___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecUINT8___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___delitem__`) = c("SWIGFunction", class('VecUINT8___delitem__'))

# Start of VecUINT8___getitem__

`VecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8___getitem__`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___getitem__`) = c("SWIGFunction", class('VecUINT8___getitem__'))

# Start of VecUINT8___setitem__

`VecUINT8___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecUINT8___setitem__`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8___setitem__`) = c("SWIGFunction", class('VecUINT8___setitem__'))

# Start of VecUINT8_append

`VecUINT8_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_append', self, x, PACKAGE='geoda');
  
}

attr(`VecUINT8_append`, 'returnType') = 'void'
attr(`VecUINT8_append`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_append`) = c("SWIGFunction", class('VecUINT8_append'))

# Start of new_VecUINT8

`VecUINT8__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecUINT8__SWIG_0', PACKAGE='geoda');
  
}

attr(`VecUINT8__SWIG_0`, 'returnType') = 'integer'
class(`VecUINT8__SWIG_0`) = c("SWIGFunction", class('VecUINT8__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_1` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  ;.Call('R_swig_new_VecUINT8__SWIG_1', s_arg1, PACKAGE='geoda');
  
}

attr(`VecUINT8__SWIG_1`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_1`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_1`) = c("SWIGFunction", class('VecUINT8__SWIG_1'))

# Start of VecUINT8_empty

`VecUINT8_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_empty`, 'returnType') = 'logical'
attr(`VecUINT8_empty`, "inputTypes") = c('integer')
class(`VecUINT8_empty`) = c("SWIGFunction", class('VecUINT8_empty'))

# Start of VecUINT8_size

`VecUINT8_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_size`, 'returnType') = 'integer'
attr(`VecUINT8_size`, "inputTypes") = c('integer')
class(`VecUINT8_size`) = c("SWIGFunction", class('VecUINT8_size'))

# Start of VecUINT8_swap

`VecUINT8_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecUINT8_swap`, 'returnType') = 'void'
attr(`VecUINT8_swap`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_swap`) = c("SWIGFunction", class('VecUINT8_swap'))

# Start of VecUINT8_clear

`VecUINT8_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_clear', self, PACKAGE='geoda');
  
}

attr(`VecUINT8_clear`, 'returnType') = 'void'
attr(`VecUINT8_clear`, "inputTypes") = c('integer')
class(`VecUINT8_clear`) = c("SWIGFunction", class('VecUINT8_clear'))

# Start of VecUINT8_get_allocator

`VecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_unsigned_char_t", ref=ans);
  
  ans
  
}

attr(`VecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_char_t'
attr(`VecUINT8_get_allocator`, "inputTypes") = c('integer')
class(`VecUINT8_get_allocator`) = c("SWIGFunction", class('VecUINT8_get_allocator'))

# Start of new_VecUINT8

`VecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecUINT8__SWIG_2', size, PACKAGE='geoda');
  
}

attr(`VecUINT8__SWIG_2`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_2`) = c("SWIGFunction", class('VecUINT8__SWIG_2'))

# Start of VecUINT8_pop_back

`VecUINT8_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecUINT8_pop_back`, "inputTypes") = c('integer')
class(`VecUINT8_pop_back`) = c("SWIGFunction", class('VecUINT8_pop_back'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecUINT8_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecUINT8__SWIG_3', size, value, PACKAGE='geoda');
  
}

attr(`VecUINT8__SWIG_3`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8__SWIG_3`) = c("SWIGFunction", class('VecUINT8__SWIG_3'))

`VecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecUINT8__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_char') && length(argv[[2]]) == 1) {
      f <- VecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_push_back

`VecUINT8_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecUINT8_push_back`, 'returnType') = 'void'
attr(`VecUINT8_push_back`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_push_back`) = c("SWIGFunction", class('VecUINT8_push_back'))

# Start of VecUINT8_front

`VecUINT8_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_front`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_front`, "inputTypes") = c('integer')
class(`VecUINT8_front`) = c("SWIGFunction", class('VecUINT8_front'))

# Start of VecUINT8_back

`VecUINT8_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_back`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_back`, "inputTypes") = c('integer')
class(`VecUINT8_back`) = c("SWIGFunction", class('VecUINT8_back'))

# Start of VecUINT8_assign

`VecUINT8_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecUINT8_assign`, 'returnType') = 'void'
attr(`VecUINT8_assign`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_assign`) = c("SWIGFunction", class('VecUINT8_assign'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_1'))

`VecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_char') && length(argv[[3]]) == 1) {
      f <- VecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_reserve

`VecUINT8_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecUINT8_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecUINT8_reserve`, 'returnType') = 'void'
attr(`VecUINT8_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_reserve`) = c("SWIGFunction", class('VecUINT8_reserve'))

# Start of VecUINT8_capacity

`VecUINT8_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecUINT8_capacity`, "inputTypes") = c('integer')
class(`VecUINT8_capacity`) = c("SWIGFunction", class('VecUINT8_capacity'))

# Start of delete_VecUINT8

`delete_VecUINT8` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecUINT8', self, PACKAGE='geoda');
  
}

attr(`delete_VecUINT8`, 'returnType') = 'void'
attr(`delete_VecUINT8`, "inputTypes") = c('integer')
class(`delete_VecUINT8`) = c("SWIGFunction", class('delete_VecUINT8'))

# Start of accessor method for std::vector<(unsigned char)>
setMethod('$', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecUINT8___nonzero__, '__len__' = VecUINT8___len__, 'pop' = VecUINT8_pop, '__getslice__' = VecUINT8___getslice__, '__setslice__' = VecUINT8___setslice__, '__delslice__' = VecUINT8___delslice__, '__delitem__' = VecUINT8___delitem__, '__getitem__' = VecUINT8___getitem__, '__setitem__' = VecUINT8___setitem__, 'append' = VecUINT8_append, 'empty' = VecUINT8_empty, 'size' = VecUINT8_size, 'swap' = VecUINT8_swap, 'clear' = VecUINT8_clear, 'get_allocator' = VecUINT8_get_allocator, 'pop_back' = VecUINT8_pop_back, 'resize' = VecUINT8_resize, 'push_back' = VecUINT8_push_back, 'front' = VecUINT8_front, 'back' = VecUINT8_back, 'assign' = VecUINT8_assign, 'reserve' = VecUINT8_reserve, 'capacity' = VecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(unsigned char)>
setMethod('delete', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(obj) {delete_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t(obj)})
# Start of VecVecUINT8___nonzero__

`VecVecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecVecUINT8___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___nonzero__`) = c("SWIGFunction", class('VecVecUINT8___nonzero__'))

# Start of VecVecUINT8___len__

`VecVecUINT8___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___len__', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8___len__`, 'returnType') = 'integer'
attr(`VecVecUINT8___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___len__`) = c("SWIGFunction", class('VecVecUINT8___len__'))

# Start of VecVecUINT8_pop

`VecVecUINT8_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_pop`, 'returnType') = 'integer'
attr(`VecVecUINT8_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop`) = c("SWIGFunction", class('VecVecUINT8_pop'))

# Start of VecVecUINT8___getslice__

`VecVecUINT8___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecUINT8___getslice__', self, i, j, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`VecVecUINT8___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___getslice__`) = c("SWIGFunction", class('VecVecUINT8___getslice__'))

# Start of VecVecUINT8___setslice__

`VecVecUINT8___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8___setslice__', self, i, j, v, PACKAGE='geoda');
  
}

attr(`VecVecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___setslice__`) = c("SWIGFunction", class('VecVecUINT8___setslice__'))

# Start of VecVecUINT8___delslice__

`VecVecUINT8___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecUINT8___delslice__', self, i, j, PACKAGE='geoda');
  
}

attr(`VecVecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___delslice__`) = c("SWIGFunction", class('VecVecUINT8___delslice__'))

# Start of VecVecUINT8___delitem__

`VecVecUINT8___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___delitem__', self, i, PACKAGE='geoda');
  
}

attr(`VecVecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___delitem__`) = c("SWIGFunction", class('VecVecUINT8___delitem__'))

# Start of VecVecUINT8___getitem__

`VecVecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8___getitem__`, 'returnType') = 'integer'
attr(`VecVecUINT8___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___getitem__`) = c("SWIGFunction", class('VecVecUINT8___getitem__'))

# Start of VecVecUINT8___setitem__

`VecVecUINT8___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8___setitem__', self, i, x, PACKAGE='geoda');
  
}

attr(`VecVecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___setitem__`) = c("SWIGFunction", class('VecVecUINT8___setitem__'))

# Start of VecVecUINT8_append

`VecVecUINT8_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_append', self, x, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_append`, 'returnType') = 'void'
attr(`VecVecUINT8_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_append`) = c("SWIGFunction", class('VecVecUINT8_append'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_0', PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
class(`VecVecUINT8__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_1', s_arg1, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8__SWIG_1'))

# Start of VecVecUINT8_empty

`VecVecUINT8_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_empty', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_empty`, 'returnType') = 'logical'
attr(`VecVecUINT8_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_empty`) = c("SWIGFunction", class('VecVecUINT8_empty'))

# Start of VecVecUINT8_size

`VecVecUINT8_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_size', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_size`, 'returnType') = 'integer'
attr(`VecVecUINT8_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_size`) = c("SWIGFunction", class('VecVecUINT8_size'))

# Start of VecVecUINT8_swap

`VecVecUINT8_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8_swap', self, v, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_swap`, 'returnType') = 'void'
attr(`VecVecUINT8_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_swap`) = c("SWIGFunction", class('VecVecUINT8_swap'))

# Start of VecVecUINT8_clear

`VecVecUINT8_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_clear', self, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_clear`, 'returnType') = 'void'
attr(`VecVecUINT8_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_clear`) = c("SWIGFunction", class('VecVecUINT8_clear'))

# Start of VecVecUINT8_get_allocator

`VecVecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t'
attr(`VecVecUINT8_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_get_allocator`) = c("SWIGFunction", class('VecVecUINT8_get_allocator'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_2', size, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecUINT8__SWIG_2`) = c("SWIGFunction", class('VecVecUINT8__SWIG_2'))

# Start of VecVecUINT8_pop_back

`VecVecUINT8_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop_back', self, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecVecUINT8_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop_back`) = c("SWIGFunction", class('VecVecUINT8_pop_back'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_0', self, new_size, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_3', size, value, PACKAGE='geoda');
  ans <- new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecVecUINT8__SWIG_3`) = c("SWIGFunction", class('VecVecUINT8__SWIG_3'))

`VecVecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecUINT8__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_push_back

`VecVecUINT8_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_push_back', self, x, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_push_back`, 'returnType') = 'void'
attr(`VecVecUINT8_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_push_back`) = c("SWIGFunction", class('VecVecUINT8_push_back'))

# Start of VecVecUINT8_front

`VecVecUINT8_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_front', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_front`, 'returnType') = 'integer'
attr(`VecVecUINT8_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_front`) = c("SWIGFunction", class('VecVecUINT8_front'))

# Start of VecVecUINT8_back

`VecVecUINT8_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_back', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_back`, 'returnType') = 'integer'
attr(`VecVecUINT8_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_back`) = c("SWIGFunction", class('VecVecUINT8_back'))

# Start of VecVecUINT8_assign

`VecVecUINT8_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_assign', self, n, x, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_assign`, 'returnType') = 'void'
attr(`VecVecUINT8_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_assign`) = c("SWIGFunction", class('VecVecUINT8_assign'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_1'))

`VecVecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_reserve

`VecVecUINT8_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecUINT8_reserve', self, n, PACKAGE='geoda');
  
}

attr(`VecVecUINT8_reserve`, 'returnType') = 'void'
attr(`VecVecUINT8_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_reserve`) = c("SWIGFunction", class('VecVecUINT8_reserve'))

# Start of VecVecUINT8_capacity

`VecVecUINT8_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_capacity', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`VecVecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecVecUINT8_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_capacity`) = c("SWIGFunction", class('VecVecUINT8_capacity'))

# Start of delete_VecVecUINT8

`delete_VecVecUINT8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecUINT8', self, PACKAGE='geoda');
  
}

attr(`delete_VecVecUINT8`, 'returnType') = 'void'
attr(`delete_VecVecUINT8`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`delete_VecVecUINT8`) = c("SWIGFunction", class('delete_VecVecUINT8'))

# Start of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecUINT8___nonzero__, '__len__' = VecVecUINT8___len__, 'pop' = VecVecUINT8_pop, '__getslice__' = VecVecUINT8___getslice__, '__setslice__' = VecVecUINT8___setslice__, '__delslice__' = VecVecUINT8___delslice__, '__delitem__' = VecVecUINT8___delitem__, '__getitem__' = VecVecUINT8___getitem__, '__setitem__' = VecVecUINT8___setitem__, 'append' = VecVecUINT8_append, 'empty' = VecVecUINT8_empty, 'size' = VecVecUINT8_size, 'swap' = VecVecUINT8_swap, 'clear' = VecVecUINT8_clear, 'get_allocator' = VecVecUINT8_get_allocator, 'pop_back' = VecVecUINT8_pop_back, 'resize' = VecVecUINT8_resize, 'push_back' = VecVecUINT8_push_back, 'front' = VecVecUINT8_front, 'back' = VecVecUINT8_back, 'assign' = VecVecUINT8_assign, 'reserve' = VecVecUINT8_reserve, 'capacity' = VecVecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t(obj)})
# Start of new_GeoDaProxy

`GeoDaProxy__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_GeoDaProxy__SWIG_0', PACKAGE='geoda');
  ans <- new("_p_GeoDaProxy", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_GeoDaProxy)
  ans
  
}

attr(`GeoDaProxy__SWIG_0`, 'returnType') = '_p_GeoDaProxy'
class(`GeoDaProxy__SWIG_0`) = c("SWIGFunction", class('GeoDaProxy__SWIG_0'))

# Start of new_GeoDaProxy

`GeoDaProxy__SWIG_1` = function(ds_path)
{
  ds_path = as(ds_path, "character"); 
  ;ans = .Call('R_swig_new_GeoDaProxy__SWIG_1', ds_path, PACKAGE='geoda');
  ans <- new("_p_GeoDaProxy", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_GeoDaProxy)
  ans
  
}

attr(`GeoDaProxy__SWIG_1`, 'returnType') = '_p_GeoDaProxy'
attr(`GeoDaProxy__SWIG_1`, "inputTypes") = c('character')
class(`GeoDaProxy__SWIG_1`) = c("SWIGFunction", class('GeoDaProxy__SWIG_1'))

`GeoDaProxy` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- GeoDaProxy__SWIG_0; 
  } else if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- GeoDaProxy__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaProxy with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GeoDaProxy

`delete_GeoDaProxy` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaProxy', self, PACKAGE='geoda');
  
}

attr(`delete_GeoDaProxy`, 'returnType') = 'void'
attr(`delete_GeoDaProxy`, "inputTypes") = c('_p_GeoDaProxy')
class(`delete_GeoDaProxy`) = c("SWIGFunction", class('delete_GeoDaProxy'))

# Start of GeoDaProxy_getLayer_names

`GeoDaProxy_getLayer_names` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaProxy_getLayer_names', self, as.logical(.copy), PACKAGE='geoda');
  ans <- new("_p_std__vectorT_char_const_p_std__allocatorT_char_const_p_t_t", ref=ans) ;
  
  ans
  
}

attr(`GeoDaProxy_getLayer_names`, 'returnType') = '_p_std__vectorT_char_const_p_std__allocatorT_char_const_p_t_t'
attr(`GeoDaProxy_getLayer_names`, "inputTypes") = c('_p_GeoDaProxy')
class(`GeoDaProxy_getLayer_names`) = c("SWIGFunction", class('GeoDaProxy_getLayer_names'))

# Start of GeoDaProxy_num_obs_set

`GeoDaProxy_num_obs_set` = function(self, s_num_obs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_num_obs = as.integer(s_num_obs);
  
  if(length(s_num_obs) > 1) {
    warning("using only the first element of s_num_obs");
  };
  
  ;.Call('R_swig_GeoDaProxy_num_obs_set', self, s_num_obs, PACKAGE='geoda');
  
}

attr(`GeoDaProxy_num_obs_set`, 'returnType') = 'void'
attr(`GeoDaProxy_num_obs_set`, "inputTypes") = c('_p_GeoDaProxy', 'integer')
class(`GeoDaProxy_num_obs_set`) = c("SWIGFunction", class('GeoDaProxy_num_obs_set'))

# Start of GeoDaProxy_num_obs_get

`GeoDaProxy_num_obs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaProxy_num_obs_get', self, as.logical(.copy), PACKAGE='geoda');
  
}

attr(`GeoDaProxy_num_obs_get`, 'returnType') = 'integer'
attr(`GeoDaProxy_num_obs_get`, "inputTypes") = c('_p_GeoDaProxy')
class(`GeoDaProxy_num_obs_get`) = c("SWIGFunction", class('GeoDaProxy_num_obs_get'))

# Start of accessor method for GeoDaProxy
setMethod('$', '_p_GeoDaProxy', function(x, name)

{
  accessorFuns = list('getLayer_names' = GeoDaProxy_getLayer_names, 'num_obs' = GeoDaProxy_num_obs_get);
  vaccessors = c('num_obs');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaProxy
# Start of accessor method for GeoDaProxy
setMethod('$<-', '_p_GeoDaProxy', function(x, name, value)

{
  accessorFuns = list('num_obs' = GeoDaProxy_num_obs_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaProxy', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('num_obs' = GeoDaProxy_num_obs_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaProxy
setMethod('delete', '_p_GeoDaProxy', function(obj) {delete_GeoDaProxy(obj)})

