# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -I../../deps/libgeoda/include -o libgeoda.cpp ../libgeoda.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_float_std__allocatorT_float_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_GeoDaWeight', contains = 'C++Reference')
setClass('_p_AbstractLocalSA', contains = 'C++Reference')
setClass('_p_UniLisa', contains = c('_p_AbstractLocalSA'))
setClass('_p_GeoDa', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of VecFloat___nonzero__

`VecFloat___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat___nonzero__`, 'returnType') = 'logical'
attr(`VecFloat___nonzero__`, "inputTypes") = c('numeric')
class(`VecFloat___nonzero__`) = c("SWIGFunction", class('VecFloat___nonzero__'))

# Start of VecFloat___len__

`VecFloat___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat___len__`, 'returnType') = 'integer'
attr(`VecFloat___len__`, "inputTypes") = c('numeric')
class(`VecFloat___len__`) = c("SWIGFunction", class('VecFloat___len__'))

# Start of VecFloat_pop

`VecFloat_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_pop`, 'returnType') = 'numeric'
attr(`VecFloat_pop`, "inputTypes") = c('numeric')
class(`VecFloat_pop`) = c("SWIGFunction", class('VecFloat_pop'))

# Start of VecFloat___getslice__

`VecFloat___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecFloat___getslice__`, 'returnType') = 'numeric'
attr(`VecFloat___getslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___getslice__`) = c("SWIGFunction", class('VecFloat___getslice__'))

# Start of VecFloat___setslice__

`VecFloat___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecFloat___setslice__`, 'returnType') = 'void'
attr(`VecFloat___setslice__`, "inputTypes") = c('numeric', 'integer', 'integer', 'numeric')
class(`VecFloat___setslice__`) = c("SWIGFunction", class('VecFloat___setslice__'))

# Start of VecFloat___delslice__

`VecFloat___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecFloat___delslice__`, 'returnType') = 'void'
attr(`VecFloat___delslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___delslice__`) = c("SWIGFunction", class('VecFloat___delslice__'))

# Start of VecFloat___delitem__

`VecFloat___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecFloat___delitem__`, 'returnType') = 'void'
attr(`VecFloat___delitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___delitem__`) = c("SWIGFunction", class('VecFloat___delitem__'))

# Start of VecFloat___getitem__

`VecFloat___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat___getitem__`, 'returnType') = 'numeric'
attr(`VecFloat___getitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___getitem__`) = c("SWIGFunction", class('VecFloat___getitem__'))

# Start of VecFloat___setitem__

`VecFloat___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecFloat___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecFloat___setitem__`, 'returnType') = 'void'
attr(`VecFloat___setitem__`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat___setitem__`) = c("SWIGFunction", class('VecFloat___setitem__'))

# Start of VecFloat_append

`VecFloat_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecFloat_append`, 'returnType') = 'void'
attr(`VecFloat_append`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_append`) = c("SWIGFunction", class('VecFloat_append'))

# Start of new_VecFloat

`VecFloat__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecFloat__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecFloat__SWIG_0`, 'returnType') = 'numeric'
class(`VecFloat__SWIG_0`) = c("SWIGFunction", class('VecFloat__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecFloat__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecFloat__SWIG_1`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_1`, "inputTypes") = c('numeric')
class(`VecFloat__SWIG_1`) = c("SWIGFunction", class('VecFloat__SWIG_1'))

# Start of VecFloat_empty

`VecFloat_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_empty`, 'returnType') = 'logical'
attr(`VecFloat_empty`, "inputTypes") = c('numeric')
class(`VecFloat_empty`) = c("SWIGFunction", class('VecFloat_empty'))

# Start of VecFloat_size

`VecFloat_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_size`, 'returnType') = 'integer'
attr(`VecFloat_size`, "inputTypes") = c('numeric')
class(`VecFloat_size`) = c("SWIGFunction", class('VecFloat_size'))

# Start of VecFloat_swap

`VecFloat_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecFloat_swap`, 'returnType') = 'void'
attr(`VecFloat_swap`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_swap`) = c("SWIGFunction", class('VecFloat_swap'))

# Start of VecFloat_clear

`VecFloat_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecFloat_clear`, 'returnType') = 'void'
attr(`VecFloat_clear`, "inputTypes") = c('numeric')
class(`VecFloat_clear`) = c("SWIGFunction", class('VecFloat_clear'))

# Start of VecFloat_get_allocator

`VecFloat_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecFloat_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_float_t", ref=ans);
  
  ans
  
}

attr(`VecFloat_get_allocator`, 'returnType') = '_p_std__allocatorT_float_t'
attr(`VecFloat_get_allocator`, "inputTypes") = c('numeric')
class(`VecFloat_get_allocator`) = c("SWIGFunction", class('VecFloat_get_allocator'))

# Start of new_VecFloat

`VecFloat__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecFloat__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecFloat__SWIG_2`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_2`, "inputTypes") = c('integer')
class(`VecFloat__SWIG_2`) = c("SWIGFunction", class('VecFloat__SWIG_2'))

# Start of VecFloat_pop_back

`VecFloat_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecFloat_pop_back`, 'returnType') = 'void'
attr(`VecFloat_pop_back`, "inputTypes") = c('numeric')
class(`VecFloat_pop_back`) = c("SWIGFunction", class('VecFloat_pop_back'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecFloat_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecFloat_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_resize__SWIG_0`) = c("SWIGFunction", class('VecFloat_resize__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecFloat__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecFloat__SWIG_3`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecFloat__SWIG_3`) = c("SWIGFunction", class('VecFloat__SWIG_3'))

`VecFloat` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecFloat__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecFloat__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecFloat__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecFloat__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_push_back

`VecFloat_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecFloat_push_back`, 'returnType') = 'void'
attr(`VecFloat_push_back`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_push_back`) = c("SWIGFunction", class('VecFloat_push_back'))

# Start of VecFloat_front

`VecFloat_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_front`, 'returnType') = 'numeric'
attr(`VecFloat_front`, "inputTypes") = c('numeric')
class(`VecFloat_front`) = c("SWIGFunction", class('VecFloat_front'))

# Start of VecFloat_back

`VecFloat_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_back`, 'returnType') = 'numeric'
attr(`VecFloat_back`, "inputTypes") = c('numeric')
class(`VecFloat_back`) = c("SWIGFunction", class('VecFloat_back'))

# Start of VecFloat_assign

`VecFloat_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecFloat_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecFloat_assign`, 'returnType') = 'void'
attr(`VecFloat_assign`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_assign`) = c("SWIGFunction", class('VecFloat_assign'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecFloat_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecFloat_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_resize__SWIG_1`) = c("SWIGFunction", class('VecFloat_resize__SWIG_1'))

`VecFloat_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecFloat_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecFloat_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_reserve

`VecFloat_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecFloat_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecFloat_reserve`, 'returnType') = 'void'
attr(`VecFloat_reserve`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_reserve`) = c("SWIGFunction", class('VecFloat_reserve'))

# Start of VecFloat_capacity

`VecFloat_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecFloat_capacity`, 'returnType') = 'integer'
attr(`VecFloat_capacity`, "inputTypes") = c('numeric')
class(`VecFloat_capacity`) = c("SWIGFunction", class('VecFloat_capacity'))

# Start of delete_VecFloat

`delete_VecFloat` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecFloat', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecFloat`, 'returnType') = 'void'
attr(`delete_VecFloat`, "inputTypes") = c('numeric')
class(`delete_VecFloat`) = c("SWIGFunction", class('delete_VecFloat'))

# Start of accessor method for std::vector<(float)>
setMethod('$', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecFloat___nonzero__, '__len__' = VecFloat___len__, 'pop' = VecFloat_pop, '__getslice__' = VecFloat___getslice__, '__setslice__' = VecFloat___setslice__, '__delslice__' = VecFloat___delslice__, '__delitem__' = VecFloat___delitem__, '__getitem__' = VecFloat___getitem__, '__setitem__' = VecFloat___setitem__, 'append' = VecFloat_append, 'empty' = VecFloat_empty, 'size' = VecFloat_size, 'swap' = VecFloat_swap, 'clear' = VecFloat_clear, 'get_allocator' = VecFloat_get_allocator, 'pop_back' = VecFloat_pop_back, 'resize' = VecFloat_resize, 'push_back' = VecFloat_push_back, 'front' = VecFloat_front, 'back' = VecFloat_back, 'assign' = VecFloat_assign, 'reserve' = VecFloat_reserve, 'capacity' = VecFloat_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(float)>
setMethod('delete', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(obj) {delete_std__vectorT_float_std__allocatorT_float_t_t(obj)})
# Start of VecString___nonzero__

`VecString___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString___nonzero__`, 'returnType') = 'logical'
attr(`VecString___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___nonzero__`) = c("SWIGFunction", class('VecString___nonzero__'))

# Start of VecString___len__

`VecString___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString___len__`, 'returnType') = 'integer'
attr(`VecString___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___len__`) = c("SWIGFunction", class('VecString___len__'))

# Start of VecString_pop

`VecString_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_pop`, 'returnType') = 'character'
attr(`VecString_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop`) = c("SWIGFunction", class('VecString_pop'))

# Start of VecString___getslice__

`VecString___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecString___getslice__', self, i, j, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`VecString___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___getslice__`) = c("SWIGFunction", class('VecString___getslice__'))

# Start of VecString___setslice__

`VecString___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecString___setslice__`, 'returnType') = 'void'
attr(`VecString___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___setslice__`) = c("SWIGFunction", class('VecString___setslice__'))

# Start of VecString___delslice__

`VecString___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecString___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecString___delslice__`, 'returnType') = 'void'
attr(`VecString___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___delslice__`) = c("SWIGFunction", class('VecString___delslice__'))

# Start of VecString___delitem__

`VecString___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecString___delitem__`, 'returnType') = 'void'
attr(`VecString___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___delitem__`) = c("SWIGFunction", class('VecString___delitem__'))

# Start of VecString___getitem__

`VecString___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString___getitem__`, 'returnType') = 'character'
attr(`VecString___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___getitem__`) = c("SWIGFunction", class('VecString___getitem__'))

# Start of VecString___setitem__

`VecString___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecString___setitem__`, 'returnType') = 'void'
attr(`VecString___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString___setitem__`) = c("SWIGFunction", class('VecString___setitem__'))

# Start of VecString_append

`VecString_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecString_append`, 'returnType') = 'void'
attr(`VecString_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_append`) = c("SWIGFunction", class('VecString_append'))

# Start of new_VecString

`VecString__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecString__SWIG_0', PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`VecString__SWIG_0`) = c("SWIGFunction", class('VecString__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecString__SWIG_1', other, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString__SWIG_1`) = c("SWIGFunction", class('VecString__SWIG_1'))

# Start of VecString_empty

`VecString_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_empty`, 'returnType') = 'logical'
attr(`VecString_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_empty`) = c("SWIGFunction", class('VecString_empty'))

# Start of VecString_size

`VecString_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_size`, 'returnType') = 'integer'
attr(`VecString_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_size`) = c("SWIGFunction", class('VecString_size'))

# Start of VecString_swap

`VecString_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecString_swap`, 'returnType') = 'void'
attr(`VecString_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_swap`) = c("SWIGFunction", class('VecString_swap'))

# Start of VecString_clear

`VecString_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecString_clear`, 'returnType') = 'void'
attr(`VecString_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_clear`) = c("SWIGFunction", class('VecString_clear'))

# Start of VecString_get_allocator

`VecString_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecString_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`VecString_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`VecString_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_get_allocator`) = c("SWIGFunction", class('VecString_get_allocator'))

# Start of new_VecString

`VecString__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecString__SWIG_2', size, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_2`, "inputTypes") = c('integer')
class(`VecString__SWIG_2`) = c("SWIGFunction", class('VecString__SWIG_2'))

# Start of VecString_pop_back

`VecString_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecString_pop_back`, 'returnType') = 'void'
attr(`VecString_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop_back`) = c("SWIGFunction", class('VecString_pop_back'))

# Start of VecString_resize

`VecString_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecString_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecString_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_resize__SWIG_0`) = c("SWIGFunction", class('VecString_resize__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_VecString__SWIG_3', size, value, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`VecString__SWIG_3`) = c("SWIGFunction", class('VecString__SWIG_3'))

`VecString` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecString__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecString__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- VecString__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecString__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecString with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_push_back

`VecString_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecString_push_back`, 'returnType') = 'void'
attr(`VecString_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_push_back`) = c("SWIGFunction", class('VecString_push_back'))

# Start of VecString_front

`VecString_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_front`, 'returnType') = 'character'
attr(`VecString_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_front`) = c("SWIGFunction", class('VecString_front'))

# Start of VecString_back

`VecString_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_back`, 'returnType') = 'character'
attr(`VecString_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_back`) = c("SWIGFunction", class('VecString_back'))

# Start of VecString_assign

`VecString_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecString_assign`, 'returnType') = 'void'
attr(`VecString_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_assign`) = c("SWIGFunction", class('VecString_assign'))

# Start of VecString_resize

`VecString_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecString_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_resize__SWIG_1`) = c("SWIGFunction", class('VecString_resize__SWIG_1'))

`VecString_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecString_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecString_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecString_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_reserve

`VecString_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecString_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecString_reserve`, 'returnType') = 'void'
attr(`VecString_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_reserve`) = c("SWIGFunction", class('VecString_reserve'))

# Start of VecString_capacity

`VecString_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecString_capacity`, 'returnType') = 'integer'
attr(`VecString_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_capacity`) = c("SWIGFunction", class('VecString_capacity'))

# Start of delete_VecString

`delete_VecString` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecString', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecString`, 'returnType') = 'void'
attr(`delete_VecString`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_VecString`) = c("SWIGFunction", class('delete_VecString'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecString___nonzero__, '__len__' = VecString___len__, 'pop' = VecString_pop, '__getslice__' = VecString___getslice__, '__setslice__' = VecString___setslice__, '__delslice__' = VecString___delslice__, '__delitem__' = VecString___delitem__, '__getitem__' = VecString___getitem__, '__setitem__' = VecString___setitem__, 'append' = VecString_append, 'empty' = VecString_empty, 'size' = VecString_size, 'swap' = VecString_swap, 'clear' = VecString_clear, 'get_allocator' = VecString_get_allocator, 'pop_back' = VecString_pop_back, 'resize' = VecString_resize, 'push_back' = VecString_push_back, 'front' = VecString_front, 'back' = VecString_back, 'assign' = VecString_assign, 'reserve' = VecString_reserve, 'capacity' = VecString_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of VecDouble___nonzero__

`VecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecDouble___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___nonzero__`) = c("SWIGFunction", class('VecDouble___nonzero__'))

# Start of VecDouble___len__

`VecDouble___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble___len__`, 'returnType') = 'integer'
attr(`VecDouble___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___len__`) = c("SWIGFunction", class('VecDouble___len__'))

# Start of VecDouble_pop

`VecDouble_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_pop`, 'returnType') = 'numeric'
attr(`VecDouble_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop`) = c("SWIGFunction", class('VecDouble_pop'))

# Start of VecDouble___getslice__

`VecDouble___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecDouble___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___getslice__`) = c("SWIGFunction", class('VecDouble___getslice__'))

# Start of VecDouble___setslice__

`VecDouble___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecDouble___setslice__`, 'returnType') = 'void'
attr(`VecDouble___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___setslice__`) = c("SWIGFunction", class('VecDouble___setslice__'))

# Start of VecDouble___delslice__

`VecDouble___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecDouble___delslice__`, 'returnType') = 'void'
attr(`VecDouble___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___delslice__`) = c("SWIGFunction", class('VecDouble___delslice__'))

# Start of VecDouble___delitem__

`VecDouble___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecDouble___delitem__`, 'returnType') = 'void'
attr(`VecDouble___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___delitem__`) = c("SWIGFunction", class('VecDouble___delitem__'))

# Start of VecDouble___getitem__

`VecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble___getitem__`, 'returnType') = 'numeric'
attr(`VecDouble___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___getitem__`) = c("SWIGFunction", class('VecDouble___getitem__'))

# Start of VecDouble___setitem__

`VecDouble___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecDouble___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecDouble___setitem__`, 'returnType') = 'void'
attr(`VecDouble___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble___setitem__`) = c("SWIGFunction", class('VecDouble___setitem__'))

# Start of VecDouble_append

`VecDouble_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecDouble_append`, 'returnType') = 'void'
attr(`VecDouble_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_append`) = c("SWIGFunction", class('VecDouble_append'))

# Start of new_VecDouble

`VecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecDouble__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecDouble__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`VecDouble__SWIG_0`) = c("SWIGFunction", class('VecDouble__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecDouble__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecDouble__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble__SWIG_1`) = c("SWIGFunction", class('VecDouble__SWIG_1'))

# Start of VecDouble_empty

`VecDouble_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_empty`, 'returnType') = 'logical'
attr(`VecDouble_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_empty`) = c("SWIGFunction", class('VecDouble_empty'))

# Start of VecDouble_size

`VecDouble_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_size`, 'returnType') = 'integer'
attr(`VecDouble_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_size`) = c("SWIGFunction", class('VecDouble_size'))

# Start of VecDouble_swap

`VecDouble_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecDouble_swap`, 'returnType') = 'void'
attr(`VecDouble_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_swap`) = c("SWIGFunction", class('VecDouble_swap'))

# Start of VecDouble_clear

`VecDouble_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecDouble_clear`, 'returnType') = 'void'
attr(`VecDouble_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_clear`) = c("SWIGFunction", class('VecDouble_clear'))

# Start of VecDouble_get_allocator

`VecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecDouble_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`VecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`VecDouble_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_get_allocator`) = c("SWIGFunction", class('VecDouble_get_allocator'))

# Start of new_VecDouble

`VecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecDouble__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecDouble__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecDouble__SWIG_2`) = c("SWIGFunction", class('VecDouble__SWIG_2'))

# Start of VecDouble_pop_back

`VecDouble_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecDouble_pop_back`, 'returnType') = 'void'
attr(`VecDouble_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop_back`) = c("SWIGFunction", class('VecDouble_pop_back'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecDouble_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecDouble_resize__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecDouble__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecDouble__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecDouble__SWIG_3`) = c("SWIGFunction", class('VecDouble__SWIG_3'))

`VecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecDouble__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_push_back

`VecDouble_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecDouble_push_back`, 'returnType') = 'void'
attr(`VecDouble_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_push_back`) = c("SWIGFunction", class('VecDouble_push_back'))

# Start of VecDouble_front

`VecDouble_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_front`, 'returnType') = 'numeric'
attr(`VecDouble_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_front`) = c("SWIGFunction", class('VecDouble_front'))

# Start of VecDouble_back

`VecDouble_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_back`, 'returnType') = 'numeric'
attr(`VecDouble_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_back`) = c("SWIGFunction", class('VecDouble_back'))

# Start of VecDouble_assign

`VecDouble_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecDouble_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecDouble_assign`, 'returnType') = 'void'
attr(`VecDouble_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_assign`) = c("SWIGFunction", class('VecDouble_assign'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecDouble_resize__SWIG_1'))

`VecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_reserve

`VecDouble_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecDouble_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecDouble_reserve`, 'returnType') = 'void'
attr(`VecDouble_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_reserve`) = c("SWIGFunction", class('VecDouble_reserve'))

# Start of VecDouble_capacity

`VecDouble_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecDouble_capacity`, 'returnType') = 'integer'
attr(`VecDouble_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_capacity`) = c("SWIGFunction", class('VecDouble_capacity'))

# Start of delete_VecDouble

`delete_VecDouble` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecDouble', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecDouble`, 'returnType') = 'void'
attr(`delete_VecDouble`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_VecDouble`) = c("SWIGFunction", class('delete_VecDouble'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecDouble___nonzero__, '__len__' = VecDouble___len__, 'pop' = VecDouble_pop, '__getslice__' = VecDouble___getslice__, '__setslice__' = VecDouble___setslice__, '__delslice__' = VecDouble___delslice__, '__delitem__' = VecDouble___delitem__, '__getitem__' = VecDouble___getitem__, '__setitem__' = VecDouble___setitem__, 'append' = VecDouble_append, 'empty' = VecDouble_empty, 'size' = VecDouble_size, 'swap' = VecDouble_swap, 'clear' = VecDouble_clear, 'get_allocator' = VecDouble_get_allocator, 'pop_back' = VecDouble_pop_back, 'resize' = VecDouble_resize, 'push_back' = VecDouble_push_back, 'front' = VecDouble_front, 'back' = VecDouble_back, 'assign' = VecDouble_assign, 'reserve' = VecDouble_reserve, 'capacity' = VecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of VecVecDouble___nonzero__

`VecVecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecVecDouble___nonzero__`, "inputTypes") = c('list')
class(`VecVecDouble___nonzero__`) = c("SWIGFunction", class('VecVecDouble___nonzero__'))

# Start of VecVecDouble___len__

`VecVecDouble___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___len__`, 'returnType') = 'integer'
attr(`VecVecDouble___len__`, "inputTypes") = c('list')
class(`VecVecDouble___len__`) = c("SWIGFunction", class('VecVecDouble___len__'))

# Start of VecVecDouble_pop

`VecVecDouble_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_pop`, 'returnType') = 'numeric'
attr(`VecVecDouble_pop`, "inputTypes") = c('list')
class(`VecVecDouble_pop`) = c("SWIGFunction", class('VecVecDouble_pop'))

# Start of VecVecDouble___getslice__

`VecVecDouble___getslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___getslice__`, 'returnType') = 'list'
attr(`VecVecDouble___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___getslice__`) = c("SWIGFunction", class('VecVecDouble___getslice__'))

# Start of VecVecDouble___setslice__

`VecVecDouble___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___setslice__`, 'returnType') = 'void'
attr(`VecVecDouble___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecDouble___setslice__`) = c("SWIGFunction", class('VecVecDouble___setslice__'))

# Start of VecVecDouble___delslice__

`VecVecDouble___delslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___delslice__`, 'returnType') = 'void'
attr(`VecVecDouble___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___delslice__`) = c("SWIGFunction", class('VecVecDouble___delslice__'))

# Start of VecVecDouble___delitem__

`VecVecDouble___delitem__` = function(self, i)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___delitem__`, 'returnType') = 'void'
attr(`VecVecDouble___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___delitem__`) = c("SWIGFunction", class('VecVecDouble___delitem__'))

# Start of VecVecDouble___getitem__

`VecVecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___getitem__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___getitem__`) = c("SWIGFunction", class('VecVecDouble___getitem__'))

# Start of VecVecDouble___setitem__

`VecVecDouble___setitem__` = function(self, i, x)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble___setitem__`, 'returnType') = 'void'
attr(`VecVecDouble___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble___setitem__`) = c("SWIGFunction", class('VecVecDouble___setitem__'))

# Start of VecVecDouble_append

`VecVecDouble_append` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_append`, 'returnType') = 'void'
attr(`VecVecDouble_append`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_append`) = c("SWIGFunction", class('VecVecDouble_append'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecDouble__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecVecDouble__SWIG_0`, 'returnType') = 'list'
class(`VecVecDouble__SWIG_0`) = c("SWIGFunction", class('VecVecDouble__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_1` = function(other)
{
  other = lapply(other, as.numeric);
  ;.Call('R_swig_new_VecVecDouble__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble__SWIG_1`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_1`, "inputTypes") = c('list')
class(`VecVecDouble__SWIG_1`) = c("SWIGFunction", class('VecVecDouble__SWIG_1'))

# Start of VecVecDouble_empty

`VecVecDouble_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_empty`, 'returnType') = 'logical'
attr(`VecVecDouble_empty`, "inputTypes") = c('list')
class(`VecVecDouble_empty`) = c("SWIGFunction", class('VecVecDouble_empty'))

# Start of VecVecDouble_size

`VecVecDouble_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_size`, 'returnType') = 'integer'
attr(`VecVecDouble_size`, "inputTypes") = c('list')
class(`VecVecDouble_size`) = c("SWIGFunction", class('VecVecDouble_size'))

# Start of VecVecDouble_swap

`VecVecDouble_swap` = function(self, v)
{
  self = lapply(self, as.numeric);
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_swap`, 'returnType') = 'void'
attr(`VecVecDouble_swap`, "inputTypes") = c('list', 'list')
class(`VecVecDouble_swap`) = c("SWIGFunction", class('VecVecDouble_swap'))

# Start of VecVecDouble_clear

`VecVecDouble_clear` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_clear`, 'returnType') = 'void'
attr(`VecVecDouble_clear`, "inputTypes") = c('list')
class(`VecVecDouble_clear`) = c("SWIGFunction", class('VecVecDouble_clear'))

# Start of VecVecDouble_get_allocator

`VecVecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;ans = .Call('R_swig_VecVecDouble_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`VecVecDouble_get_allocator`, "inputTypes") = c('list')
class(`VecVecDouble_get_allocator`) = c("SWIGFunction", class('VecVecDouble_get_allocator'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecDouble__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble__SWIG_2`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecDouble__SWIG_2`) = c("SWIGFunction", class('VecVecDouble__SWIG_2'))

# Start of VecVecDouble_pop_back

`VecVecDouble_pop_back` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_pop_back`, 'returnType') = 'void'
attr(`VecVecDouble_pop_back`, "inputTypes") = c('list')
class(`VecVecDouble_pop_back`) = c("SWIGFunction", class('VecVecDouble_pop_back'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecDouble_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.numeric(value);
  ;.Call('R_swig_new_VecVecDouble__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble__SWIG_3`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble__SWIG_3`) = c("SWIGFunction", class('VecVecDouble__SWIG_3'))

`VecVecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecDouble__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- VecVecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_push_back

`VecVecDouble_push_back` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_push_back`, 'returnType') = 'void'
attr(`VecVecDouble_push_back`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_push_back`) = c("SWIGFunction", class('VecVecDouble_push_back'))

# Start of VecVecDouble_front

`VecVecDouble_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_front`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_front`, "inputTypes") = c('list')
class(`VecVecDouble_front`) = c("SWIGFunction", class('VecVecDouble_front'))

# Start of VecVecDouble_back

`VecVecDouble_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_back`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_back`, "inputTypes") = c('list')
class(`VecVecDouble_back`) = c("SWIGFunction", class('VecVecDouble_back'))

# Start of VecVecDouble_assign

`VecVecDouble_assign` = function(self, n, x)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_assign`, 'returnType') = 'void'
attr(`VecVecDouble_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_assign`) = c("SWIGFunction", class('VecVecDouble_assign'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_1'))

`VecVecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) )) {
      f <- VecVecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_reserve

`VecVecDouble_reserve` = function(self, n)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecDouble_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_reserve`, 'returnType') = 'void'
attr(`VecVecDouble_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_reserve`) = c("SWIGFunction", class('VecVecDouble_reserve'))

# Start of VecVecDouble_capacity

`VecVecDouble_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecDouble_capacity`, 'returnType') = 'integer'
attr(`VecVecDouble_capacity`, "inputTypes") = c('list')
class(`VecVecDouble_capacity`) = c("SWIGFunction", class('VecVecDouble_capacity'))

# Start of delete_VecVecDouble

`delete_VecVecDouble` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_delete_VecVecDouble', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecVecDouble`, 'returnType') = 'void'
attr(`delete_VecVecDouble`, "inputTypes") = c('list')
class(`delete_VecVecDouble`) = c("SWIGFunction", class('delete_VecVecDouble'))

# Start of accessor method for std::vector<(std::vector<(double)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecDouble___nonzero__, '__len__' = VecVecDouble___len__, 'pop' = VecVecDouble_pop, '__getslice__' = VecVecDouble___getslice__, '__setslice__' = VecVecDouble___setslice__, '__delslice__' = VecVecDouble___delslice__, '__delitem__' = VecVecDouble___delitem__, '__getitem__' = VecVecDouble___getitem__, '__setitem__' = VecVecDouble___setitem__, 'append' = VecVecDouble_append, 'empty' = VecVecDouble_empty, 'size' = VecVecDouble_size, 'swap' = VecVecDouble_swap, 'clear' = VecVecDouble_clear, 'get_allocator' = VecVecDouble_get_allocator, 'pop_back' = VecVecDouble_pop_back, 'resize' = VecVecDouble_resize, 'push_back' = VecVecDouble_push_back, 'front' = VecVecDouble_front, 'back' = VecVecDouble_back, 'assign' = VecVecDouble_assign, 'reserve' = VecVecDouble_reserve, 'capacity' = VecVecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(double)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t(obj)})
# Start of VecInt___nonzero__

`VecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecInt___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___nonzero__`) = c("SWIGFunction", class('VecInt___nonzero__'))

# Start of VecInt___len__

`VecInt___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt___len__`, 'returnType') = 'integer'
attr(`VecInt___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___len__`) = c("SWIGFunction", class('VecInt___len__'))

# Start of VecInt_pop

`VecInt_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_pop`, 'returnType') = 'integer'
attr(`VecInt_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop`) = c("SWIGFunction", class('VecInt_pop'))

# Start of VecInt___getslice__

`VecInt___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecInt___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___getslice__`) = c("SWIGFunction", class('VecInt___getslice__'))

# Start of VecInt___setslice__

`VecInt___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecInt___setslice__`, 'returnType') = 'void'
attr(`VecInt___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___setslice__`) = c("SWIGFunction", class('VecInt___setslice__'))

# Start of VecInt___delslice__

`VecInt___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecInt___delslice__`, 'returnType') = 'void'
attr(`VecInt___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___delslice__`) = c("SWIGFunction", class('VecInt___delslice__'))

# Start of VecInt___delitem__

`VecInt___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecInt___delitem__`, 'returnType') = 'void'
attr(`VecInt___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___delitem__`) = c("SWIGFunction", class('VecInt___delitem__'))

# Start of VecInt___getitem__

`VecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt___getitem__`, 'returnType') = 'integer'
attr(`VecInt___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___getitem__`) = c("SWIGFunction", class('VecInt___getitem__'))

# Start of VecInt___setitem__

`VecInt___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecInt___setitem__`, 'returnType') = 'void'
attr(`VecInt___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___setitem__`) = c("SWIGFunction", class('VecInt___setitem__'))

# Start of VecInt_append

`VecInt_append` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecInt_append`, 'returnType') = 'void'
attr(`VecInt_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_append`) = c("SWIGFunction", class('VecInt_append'))

# Start of new_VecInt

`VecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecInt__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`VecInt__SWIG_0`) = c("SWIGFunction", class('VecInt__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecInt__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecInt__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt__SWIG_1`) = c("SWIGFunction", class('VecInt__SWIG_1'))

# Start of VecInt_empty

`VecInt_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_empty`, 'returnType') = 'logical'
attr(`VecInt_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_empty`) = c("SWIGFunction", class('VecInt_empty'))

# Start of VecInt_size

`VecInt_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_size`, 'returnType') = 'integer'
attr(`VecInt_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_size`) = c("SWIGFunction", class('VecInt_size'))

# Start of VecInt_swap

`VecInt_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecInt_swap`, 'returnType') = 'void'
attr(`VecInt_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_swap`) = c("SWIGFunction", class('VecInt_swap'))

# Start of VecInt_clear

`VecInt_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecInt_clear`, 'returnType') = 'void'
attr(`VecInt_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_clear`) = c("SWIGFunction", class('VecInt_clear'))

# Start of VecInt_get_allocator

`VecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_int_t", ref=ans);
  
  ans
  
}

attr(`VecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`VecInt_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_get_allocator`) = c("SWIGFunction", class('VecInt_get_allocator'))

# Start of new_VecInt

`VecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecInt__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt__SWIG_2`) = c("SWIGFunction", class('VecInt__SWIG_2'))

# Start of VecInt_pop_back

`VecInt_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecInt_pop_back`, 'returnType') = 'void'
attr(`VecInt_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop_back`) = c("SWIGFunction", class('VecInt_pop_back'))

# Start of VecInt_resize

`VecInt_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecInt_resize__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecInt__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecInt__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecInt__SWIG_3`) = c("SWIGFunction", class('VecInt__SWIG_3'))

`VecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_push_back

`VecInt_push_back` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecInt_push_back`, 'returnType') = 'void'
attr(`VecInt_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_push_back`) = c("SWIGFunction", class('VecInt_push_back'))

# Start of VecInt_front

`VecInt_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_front`, 'returnType') = 'integer'
attr(`VecInt_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_front`) = c("SWIGFunction", class('VecInt_front'))

# Start of VecInt_back

`VecInt_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_back`, 'returnType') = 'integer'
attr(`VecInt_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_back`) = c("SWIGFunction", class('VecInt_back'))

# Start of VecInt_assign

`VecInt_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecInt_assign`, 'returnType') = 'void'
attr(`VecInt_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_assign`) = c("SWIGFunction", class('VecInt_assign'))

# Start of VecInt_resize

`VecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecInt_resize__SWIG_1'))

`VecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- VecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_reserve

`VecInt_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecInt_reserve`, 'returnType') = 'void'
attr(`VecInt_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_reserve`) = c("SWIGFunction", class('VecInt_reserve'))

# Start of VecInt_capacity

`VecInt_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecInt_capacity`, 'returnType') = 'integer'
attr(`VecInt_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_capacity`) = c("SWIGFunction", class('VecInt_capacity'))

# Start of delete_VecInt

`delete_VecInt` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecInt`, 'returnType') = 'void'
attr(`delete_VecInt`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_VecInt`) = c("SWIGFunction", class('delete_VecInt'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt___nonzero__, '__len__' = VecInt___len__, 'pop' = VecInt_pop, '__getslice__' = VecInt___getslice__, '__setslice__' = VecInt___setslice__, '__delslice__' = VecInt___delslice__, '__delitem__' = VecInt___delitem__, '__getitem__' = VecInt___getitem__, '__setitem__' = VecInt___setitem__, 'append' = VecInt_append, 'empty' = VecInt_empty, 'size' = VecInt_size, 'swap' = VecInt_swap, 'clear' = VecInt_clear, 'get_allocator' = VecInt_get_allocator, 'pop_back' = VecInt_pop_back, 'resize' = VecInt_resize, 'push_back' = VecInt_push_back, 'front' = VecInt_front, 'back' = VecInt_back, 'assign' = VecInt_assign, 'reserve' = VecInt_reserve, 'capacity' = VecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of VecVecInt___nonzero__

`VecVecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecVecInt___nonzero__`, "inputTypes") = c('list')
class(`VecVecInt___nonzero__`) = c("SWIGFunction", class('VecVecInt___nonzero__'))

# Start of VecVecInt___len__

`VecVecInt___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt___len__`, 'returnType') = 'integer'
attr(`VecVecInt___len__`, "inputTypes") = c('list')
class(`VecVecInt___len__`) = c("SWIGFunction", class('VecVecInt___len__'))

# Start of VecVecInt_pop

`VecVecInt_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_pop`, 'returnType') = 'integer'
attr(`VecVecInt_pop`, "inputTypes") = c('list')
class(`VecVecInt_pop`) = c("SWIGFunction", class('VecVecInt_pop'))

# Start of VecVecInt___getslice__

`VecVecInt___getslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecVecInt___getslice__`, 'returnType') = 'list'
attr(`VecVecInt___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___getslice__`) = c("SWIGFunction", class('VecVecInt___getslice__'))

# Start of VecVecInt___setslice__

`VecVecInt___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecVecInt___setslice__`, 'returnType') = 'void'
attr(`VecVecInt___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecInt___setslice__`) = c("SWIGFunction", class('VecVecInt___setslice__'))

# Start of VecVecInt___delslice__

`VecVecInt___delslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecVecInt___delslice__`, 'returnType') = 'void'
attr(`VecVecInt___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___delslice__`) = c("SWIGFunction", class('VecVecInt___delslice__'))

# Start of VecVecInt___delitem__

`VecVecInt___delitem__` = function(self, i)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecVecInt___delitem__`, 'returnType') = 'void'
attr(`VecVecInt___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___delitem__`) = c("SWIGFunction", class('VecVecInt___delitem__'))

# Start of VecVecInt___getitem__

`VecVecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt___getitem__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___getitem__`) = c("SWIGFunction", class('VecVecInt___getitem__'))

# Start of VecVecInt___setitem__

`VecVecInt___setitem__` = function(self, i, x)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecVecInt___setitem__`, 'returnType') = 'void'
attr(`VecVecInt___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt___setitem__`) = c("SWIGFunction", class('VecVecInt___setitem__'))

# Start of VecVecInt_append

`VecVecInt_append` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_append`, 'returnType') = 'void'
attr(`VecVecInt_append`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_append`) = c("SWIGFunction", class('VecVecInt_append'))

# Start of new_VecVecInt

`VecVecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecInt__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecVecInt__SWIG_0`, 'returnType') = 'list'
class(`VecVecInt__SWIG_0`) = c("SWIGFunction", class('VecVecInt__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_1` = function(other)
{
  other = lapply(other, as.integer);
  ;.Call('R_swig_new_VecVecInt__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecVecInt__SWIG_1`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_1`, "inputTypes") = c('list')
class(`VecVecInt__SWIG_1`) = c("SWIGFunction", class('VecVecInt__SWIG_1'))

# Start of VecVecInt_empty

`VecVecInt_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_empty`, 'returnType') = 'logical'
attr(`VecVecInt_empty`, "inputTypes") = c('list')
class(`VecVecInt_empty`) = c("SWIGFunction", class('VecVecInt_empty'))

# Start of VecVecInt_size

`VecVecInt_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_size`, 'returnType') = 'integer'
attr(`VecVecInt_size`, "inputTypes") = c('list')
class(`VecVecInt_size`) = c("SWIGFunction", class('VecVecInt_size'))

# Start of VecVecInt_swap

`VecVecInt_swap` = function(self, v)
{
  self = lapply(self, as.integer);
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_swap`, 'returnType') = 'void'
attr(`VecVecInt_swap`, "inputTypes") = c('list', 'list')
class(`VecVecInt_swap`) = c("SWIGFunction", class('VecVecInt_swap'))

# Start of VecVecInt_clear

`VecVecInt_clear` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_clear`, 'returnType') = 'void'
attr(`VecVecInt_clear`, "inputTypes") = c('list')
class(`VecVecInt_clear`) = c("SWIGFunction", class('VecVecInt_clear'))

# Start of VecVecInt_get_allocator

`VecVecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;ans = .Call('R_swig_VecVecInt_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t'
attr(`VecVecInt_get_allocator`, "inputTypes") = c('list')
class(`VecVecInt_get_allocator`) = c("SWIGFunction", class('VecVecInt_get_allocator'))

# Start of new_VecVecInt

`VecVecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecInt__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecVecInt__SWIG_2`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecInt__SWIG_2`) = c("SWIGFunction", class('VecVecInt__SWIG_2'))

# Start of VecVecInt_pop_back

`VecVecInt_pop_back` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_pop_back`, 'returnType') = 'void'
attr(`VecVecInt_pop_back`, "inputTypes") = c('list')
class(`VecVecInt_pop_back`) = c("SWIGFunction", class('VecVecInt_pop_back'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecInt_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecVecInt__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecVecInt__SWIG_3`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt__SWIG_3`) = c("SWIGFunction", class('VecVecInt__SWIG_3'))

`VecVecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecInt__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_push_back

`VecVecInt_push_back` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_push_back`, 'returnType') = 'void'
attr(`VecVecInt_push_back`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_push_back`) = c("SWIGFunction", class('VecVecInt_push_back'))

# Start of VecVecInt_front

`VecVecInt_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_front`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_front`, "inputTypes") = c('list')
class(`VecVecInt_front`) = c("SWIGFunction", class('VecVecInt_front'))

# Start of VecVecInt_back

`VecVecInt_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_back`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_back`, "inputTypes") = c('list')
class(`VecVecInt_back`) = c("SWIGFunction", class('VecVecInt_back'))

# Start of VecVecInt_assign

`VecVecInt_assign` = function(self, n, x)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_assign`, 'returnType') = 'void'
attr(`VecVecInt_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_assign`) = c("SWIGFunction", class('VecVecInt_assign'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_1'))

`VecVecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_reserve

`VecVecInt_reserve` = function(self, n)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecInt_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecVecInt_reserve`, 'returnType') = 'void'
attr(`VecVecInt_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_reserve`) = c("SWIGFunction", class('VecVecInt_reserve'))

# Start of VecVecInt_capacity

`VecVecInt_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecInt_capacity`, 'returnType') = 'integer'
attr(`VecVecInt_capacity`, "inputTypes") = c('list')
class(`VecVecInt_capacity`) = c("SWIGFunction", class('VecVecInt_capacity'))

# Start of delete_VecVecInt

`delete_VecVecInt` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_delete_VecVecInt', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecVecInt`, 'returnType') = 'void'
attr(`delete_VecVecInt`, "inputTypes") = c('list')
class(`delete_VecVecInt`) = c("SWIGFunction", class('delete_VecVecInt'))

# Start of accessor method for std::vector<(std::vector<(int)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecInt___nonzero__, '__len__' = VecVecInt___len__, 'pop' = VecVecInt_pop, '__getslice__' = VecVecInt___getslice__, '__setslice__' = VecVecInt___setslice__, '__delslice__' = VecVecInt___delslice__, '__delitem__' = VecVecInt___delitem__, '__getitem__' = VecVecInt___getitem__, '__setitem__' = VecVecInt___setitem__, 'append' = VecVecInt_append, 'empty' = VecVecInt_empty, 'size' = VecVecInt_size, 'swap' = VecVecInt_swap, 'clear' = VecVecInt_clear, 'get_allocator' = VecVecInt_get_allocator, 'pop_back' = VecVecInt_pop_back, 'resize' = VecVecInt_resize, 'push_back' = VecVecInt_push_back, 'front' = VecVecInt_front, 'back' = VecVecInt_back, 'assign' = VecVecInt_assign, 'reserve' = VecVecInt_reserve, 'capacity' = VecVecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(int)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t(obj)})
# Start of VecUINT8___nonzero__

`VecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecUINT8___nonzero__`, "inputTypes") = c('integer')
class(`VecUINT8___nonzero__`) = c("SWIGFunction", class('VecUINT8___nonzero__'))

# Start of VecUINT8___len__

`VecUINT8___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8___len__`, 'returnType') = 'integer'
attr(`VecUINT8___len__`, "inputTypes") = c('integer')
class(`VecUINT8___len__`) = c("SWIGFunction", class('VecUINT8___len__'))

# Start of VecUINT8_pop

`VecUINT8_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_pop`, 'returnType') = 'integer'
attr(`VecUINT8_pop`, "inputTypes") = c('integer')
class(`VecUINT8_pop`) = c("SWIGFunction", class('VecUINT8_pop'))

# Start of VecUINT8___getslice__

`VecUINT8___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___getslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecUINT8___getslice__`, 'returnType') = 'integer'
attr(`VecUINT8___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___getslice__`) = c("SWIGFunction", class('VecUINT8___getslice__'))

# Start of VecUINT8___setslice__

`VecUINT8___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecUINT8___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecUINT8___setslice__`) = c("SWIGFunction", class('VecUINT8___setslice__'))

# Start of VecUINT8___delslice__

`VecUINT8___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecUINT8___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___delslice__`) = c("SWIGFunction", class('VecUINT8___delslice__'))

# Start of VecUINT8___delitem__

`VecUINT8___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecUINT8___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___delitem__`) = c("SWIGFunction", class('VecUINT8___delitem__'))

# Start of VecUINT8___getitem__

`VecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8___getitem__`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___getitem__`) = c("SWIGFunction", class('VecUINT8___getitem__'))

# Start of VecUINT8___setitem__

`VecUINT8___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecUINT8___setitem__`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8___setitem__`) = c("SWIGFunction", class('VecUINT8___setitem__'))

# Start of VecUINT8_append

`VecUINT8_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_append`, 'returnType') = 'void'
attr(`VecUINT8_append`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_append`) = c("SWIGFunction", class('VecUINT8_append'))

# Start of new_VecUINT8

`VecUINT8__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecUINT8__SWIG_0', PACKAGE='libgeoda');
  
}

attr(`VecUINT8__SWIG_0`, 'returnType') = 'integer'
class(`VecUINT8__SWIG_0`) = c("SWIGFunction", class('VecUINT8__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecUINT8__SWIG_1', other, PACKAGE='libgeoda');
  
}

attr(`VecUINT8__SWIG_1`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_1`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_1`) = c("SWIGFunction", class('VecUINT8__SWIG_1'))

# Start of VecUINT8_empty

`VecUINT8_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_empty`, 'returnType') = 'logical'
attr(`VecUINT8_empty`, "inputTypes") = c('integer')
class(`VecUINT8_empty`) = c("SWIGFunction", class('VecUINT8_empty'))

# Start of VecUINT8_size

`VecUINT8_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_size`, 'returnType') = 'integer'
attr(`VecUINT8_size`, "inputTypes") = c('integer')
class(`VecUINT8_size`) = c("SWIGFunction", class('VecUINT8_size'))

# Start of VecUINT8_swap

`VecUINT8_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_swap`, 'returnType') = 'void'
attr(`VecUINT8_swap`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_swap`) = c("SWIGFunction", class('VecUINT8_swap'))

# Start of VecUINT8_clear

`VecUINT8_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_clear`, 'returnType') = 'void'
attr(`VecUINT8_clear`, "inputTypes") = c('integer')
class(`VecUINT8_clear`) = c("SWIGFunction", class('VecUINT8_clear'))

# Start of VecUINT8_get_allocator

`VecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_unsigned_char_t", ref=ans);
  
  ans
  
}

attr(`VecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_char_t'
attr(`VecUINT8_get_allocator`, "inputTypes") = c('integer')
class(`VecUINT8_get_allocator`) = c("SWIGFunction", class('VecUINT8_get_allocator'))

# Start of new_VecUINT8

`VecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecUINT8__SWIG_2', size, PACKAGE='libgeoda');
  
}

attr(`VecUINT8__SWIG_2`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_2`) = c("SWIGFunction", class('VecUINT8__SWIG_2'))

# Start of VecUINT8_pop_back

`VecUINT8_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecUINT8_pop_back`, "inputTypes") = c('integer')
class(`VecUINT8_pop_back`) = c("SWIGFunction", class('VecUINT8_pop_back'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecUINT8_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecUINT8__SWIG_3', size, value, PACKAGE='libgeoda');
  
}

attr(`VecUINT8__SWIG_3`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8__SWIG_3`) = c("SWIGFunction", class('VecUINT8__SWIG_3'))

`VecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecUINT8__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_char') && length(argv[[2]]) == 1) {
      f <- VecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_push_back

`VecUINT8_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_push_back`, 'returnType') = 'void'
attr(`VecUINT8_push_back`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_push_back`) = c("SWIGFunction", class('VecUINT8_push_back'))

# Start of VecUINT8_front

`VecUINT8_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_front`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_front`, "inputTypes") = c('integer')
class(`VecUINT8_front`) = c("SWIGFunction", class('VecUINT8_front'))

# Start of VecUINT8_back

`VecUINT8_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_back`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_back`, "inputTypes") = c('integer')
class(`VecUINT8_back`) = c("SWIGFunction", class('VecUINT8_back'))

# Start of VecUINT8_assign

`VecUINT8_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_assign`, 'returnType') = 'void'
attr(`VecUINT8_assign`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_assign`) = c("SWIGFunction", class('VecUINT8_assign'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_1'))

`VecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_char') && length(argv[[3]]) == 1) {
      f <- VecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_reserve

`VecUINT8_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecUINT8_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecUINT8_reserve`, 'returnType') = 'void'
attr(`VecUINT8_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_reserve`) = c("SWIGFunction", class('VecUINT8_reserve'))

# Start of VecUINT8_capacity

`VecUINT8_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecUINT8_capacity`, "inputTypes") = c('integer')
class(`VecUINT8_capacity`) = c("SWIGFunction", class('VecUINT8_capacity'))

# Start of delete_VecUINT8

`delete_VecUINT8` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecUINT8', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecUINT8`, 'returnType') = 'void'
attr(`delete_VecUINT8`, "inputTypes") = c('integer')
class(`delete_VecUINT8`) = c("SWIGFunction", class('delete_VecUINT8'))

# Start of accessor method for std::vector<(unsigned char)>
setMethod('$', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecUINT8___nonzero__, '__len__' = VecUINT8___len__, 'pop' = VecUINT8_pop, '__getslice__' = VecUINT8___getslice__, '__setslice__' = VecUINT8___setslice__, '__delslice__' = VecUINT8___delslice__, '__delitem__' = VecUINT8___delitem__, '__getitem__' = VecUINT8___getitem__, '__setitem__' = VecUINT8___setitem__, 'append' = VecUINT8_append, 'empty' = VecUINT8_empty, 'size' = VecUINT8_size, 'swap' = VecUINT8_swap, 'clear' = VecUINT8_clear, 'get_allocator' = VecUINT8_get_allocator, 'pop_back' = VecUINT8_pop_back, 'resize' = VecUINT8_resize, 'push_back' = VecUINT8_push_back, 'front' = VecUINT8_front, 'back' = VecUINT8_back, 'assign' = VecUINT8_assign, 'reserve' = VecUINT8_reserve, 'capacity' = VecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(unsigned char)>
setMethod('delete', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(obj) {delete_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t(obj)})
# Start of VecVecUINT8___nonzero__

`VecVecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecVecUINT8___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___nonzero__`) = c("SWIGFunction", class('VecVecUINT8___nonzero__'))

# Start of VecVecUINT8___len__

`VecVecUINT8___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___len__', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___len__`, 'returnType') = 'integer'
attr(`VecVecUINT8___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___len__`) = c("SWIGFunction", class('VecVecUINT8___len__'))

# Start of VecVecUINT8_pop

`VecVecUINT8_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_pop`, 'returnType') = 'integer'
attr(`VecVecUINT8_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop`) = c("SWIGFunction", class('VecVecUINT8_pop'))

# Start of VecVecUINT8___getslice__

`VecVecUINT8___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecUINT8___getslice__', self, i, j, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___getslice__`) = c("SWIGFunction", class('VecVecUINT8___getslice__'))

# Start of VecVecUINT8___setslice__

`VecVecUINT8___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8___setslice__', self, i, j, v, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___setslice__`) = c("SWIGFunction", class('VecVecUINT8___setslice__'))

# Start of VecVecUINT8___delslice__

`VecVecUINT8___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecUINT8___delslice__', self, i, j, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___delslice__`) = c("SWIGFunction", class('VecVecUINT8___delslice__'))

# Start of VecVecUINT8___delitem__

`VecVecUINT8___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___delitem__', self, i, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___delitem__`) = c("SWIGFunction", class('VecVecUINT8___delitem__'))

# Start of VecVecUINT8___getitem__

`VecVecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___getitem__`, 'returnType') = 'integer'
attr(`VecVecUINT8___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___getitem__`) = c("SWIGFunction", class('VecVecUINT8___getitem__'))

# Start of VecVecUINT8___setitem__

`VecVecUINT8___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8___setitem__', self, i, x, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___setitem__`) = c("SWIGFunction", class('VecVecUINT8___setitem__'))

# Start of VecVecUINT8_append

`VecVecUINT8_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_append', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_append`, 'returnType') = 'void'
attr(`VecVecUINT8_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_append`) = c("SWIGFunction", class('VecVecUINT8_append'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_0', PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
class(`VecVecUINT8__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_1', other, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8__SWIG_1'))

# Start of VecVecUINT8_empty

`VecVecUINT8_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_empty', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_empty`, 'returnType') = 'logical'
attr(`VecVecUINT8_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_empty`) = c("SWIGFunction", class('VecVecUINT8_empty'))

# Start of VecVecUINT8_size

`VecVecUINT8_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_size', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_size`, 'returnType') = 'integer'
attr(`VecVecUINT8_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_size`) = c("SWIGFunction", class('VecVecUINT8_size'))

# Start of VecVecUINT8_swap

`VecVecUINT8_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8_swap', self, v, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_swap`, 'returnType') = 'void'
attr(`VecVecUINT8_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_swap`) = c("SWIGFunction", class('VecVecUINT8_swap'))

# Start of VecVecUINT8_clear

`VecVecUINT8_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_clear', self, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_clear`, 'returnType') = 'void'
attr(`VecVecUINT8_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_clear`) = c("SWIGFunction", class('VecVecUINT8_clear'))

# Start of VecVecUINT8_get_allocator

`VecVecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t'
attr(`VecVecUINT8_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_get_allocator`) = c("SWIGFunction", class('VecVecUINT8_get_allocator'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_2', size, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecUINT8__SWIG_2`) = c("SWIGFunction", class('VecVecUINT8__SWIG_2'))

# Start of VecVecUINT8_pop_back

`VecVecUINT8_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop_back', self, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecVecUINT8_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop_back`) = c("SWIGFunction", class('VecVecUINT8_pop_back'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_0', self, new_size, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_3', size, value, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecVecUINT8__SWIG_3`) = c("SWIGFunction", class('VecVecUINT8__SWIG_3'))

`VecVecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecUINT8__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_push_back

`VecVecUINT8_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_push_back', self, x, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_push_back`, 'returnType') = 'void'
attr(`VecVecUINT8_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_push_back`) = c("SWIGFunction", class('VecVecUINT8_push_back'))

# Start of VecVecUINT8_front

`VecVecUINT8_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_front', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_front`, 'returnType') = 'integer'
attr(`VecVecUINT8_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_front`) = c("SWIGFunction", class('VecVecUINT8_front'))

# Start of VecVecUINT8_back

`VecVecUINT8_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_back', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_back`, 'returnType') = 'integer'
attr(`VecVecUINT8_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_back`) = c("SWIGFunction", class('VecVecUINT8_back'))

# Start of VecVecUINT8_assign

`VecVecUINT8_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_assign', self, n, x, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_assign`, 'returnType') = 'void'
attr(`VecVecUINT8_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_assign`) = c("SWIGFunction", class('VecVecUINT8_assign'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_1'))

`VecVecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_reserve

`VecVecUINT8_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecUINT8_reserve', self, n, PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_reserve`, 'returnType') = 'void'
attr(`VecVecUINT8_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_reserve`) = c("SWIGFunction", class('VecVecUINT8_reserve'))

# Start of VecVecUINT8_capacity

`VecVecUINT8_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_capacity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`VecVecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecVecUINT8_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_capacity`) = c("SWIGFunction", class('VecVecUINT8_capacity'))

# Start of delete_VecVecUINT8

`delete_VecVecUINT8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecUINT8', self, PACKAGE='libgeoda');
  
}

attr(`delete_VecVecUINT8`, 'returnType') = 'void'
attr(`delete_VecVecUINT8`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`delete_VecVecUINT8`) = c("SWIGFunction", class('delete_VecVecUINT8'))

# Start of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecUINT8___nonzero__, '__len__' = VecVecUINT8___len__, 'pop' = VecVecUINT8_pop, '__getslice__' = VecVecUINT8___getslice__, '__setslice__' = VecVecUINT8___setslice__, '__delslice__' = VecVecUINT8___delslice__, '__delitem__' = VecVecUINT8___delitem__, '__getitem__' = VecVecUINT8___getitem__, '__setitem__' = VecVecUINT8___setitem__, 'append' = VecVecUINT8_append, 'empty' = VecVecUINT8_empty, 'size' = VecVecUINT8_size, 'swap' = VecVecUINT8_swap, 'clear' = VecVecUINT8_clear, 'get_allocator' = VecVecUINT8_get_allocator, 'pop_back' = VecVecUINT8_pop_back, 'resize' = VecVecUINT8_resize, 'push_back' = VecVecUINT8_push_back, 'front' = VecVecUINT8_front, 'back' = VecVecUINT8_back, 'assign' = VecVecUINT8_assign, 'reserve' = VecVecUINT8_reserve, 'capacity' = VecVecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t(obj)})
# Start of delete_GeoDaWeight

`delete_GeoDaWeight` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaWeight', self, PACKAGE='libgeoda');
  
}

attr(`delete_GeoDaWeight`, 'returnType') = 'void'
attr(`delete_GeoDaWeight`, "inputTypes") = c('_p_GeoDaWeight')
class(`delete_GeoDaWeight`) = c("SWIGFunction", class('delete_GeoDaWeight'))

# Start of GeoDaWeight_SaveDIDWeights

`GeoDaWeight_SaveDIDWeights` = function(self, num_obs, newids, stack_ids, ofname, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  num_obs = as.integer(num_obs);
  
  if(length(num_obs) > 1) {
    warning("using only the first element of num_obs");
  };
  
  if (inherits(newids, "ExternalReference")) newids = slot(newids,"ref") 
  if (inherits(stack_ids, "ExternalReference")) stack_ids = slot(stack_ids,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveDIDWeights', self, num_obs, newids, stack_ids, ofname, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_SaveDIDWeights`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveDIDWeights`, "inputTypes") = c('_p_GeoDaWeight', 'integer', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t', '_p_wxString')
class(`GeoDaWeight_SaveDIDWeights`) = c("SWIGFunction", class('GeoDaWeight_SaveDIDWeights'))

# Start of GeoDaWeight_SaveSpaceTimeWeights

`GeoDaWeight_SaveSpaceTimeWeights` = function(self, ofname, id_vec, time_ids, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  if (inherits(time_ids, "ExternalReference")) time_ids = slot(time_ids,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveSpaceTimeWeights', self, ofname, id_vec, time_ids, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_SaveSpaceTimeWeights`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveSpaceTimeWeights`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t')
class(`GeoDaWeight_SaveSpaceTimeWeights`) = c("SWIGFunction", class('GeoDaWeight_SaveSpaceTimeWeights'))

# Start of GeoDaWeight_CheckNeighbor

`GeoDaWeight_CheckNeighbor` = function(self, obs_idx, nbr_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  nbr_idx = as.integer(nbr_idx);
  
  if(length(nbr_idx) > 1) {
    warning("using only the first element of nbr_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_CheckNeighbor', self, obs_idx, nbr_idx, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_CheckNeighbor`, 'returnType') = 'logical'
attr(`GeoDaWeight_CheckNeighbor`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer')
class(`GeoDaWeight_CheckNeighbor`) = c("SWIGFunction", class('GeoDaWeight_CheckNeighbor'))

# Start of GeoDaWeight_GetNeighbors

`GeoDaWeight_GetNeighbors` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;ans = .Call('R_swig_GeoDaWeight_GetNeighbors', self, obs_idx, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetNeighbors`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`GeoDaWeight_GetNeighbors`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNeighbors`) = c("SWIGFunction", class('GeoDaWeight_GetNeighbors'))

# Start of GeoDaWeight_Update

`GeoDaWeight_Update` = function(self, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaWeight_Update', self, undefs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_Update`, 'returnType') = 'void'
attr(`GeoDaWeight_Update`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaWeight_Update`) = c("SWIGFunction", class('GeoDaWeight_Update'))

# Start of GeoDaWeight_HasIsolates

`GeoDaWeight_HasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_HasIsolates', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_HasIsolates`, 'returnType') = 'logical'
attr(`GeoDaWeight_HasIsolates`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_HasIsolates`) = c("SWIGFunction", class('GeoDaWeight_HasIsolates'))

# Start of GeoDaWeight_GetNbrStats

`GeoDaWeight_GetNbrStats` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNbrStats', self, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetNbrStats`, 'returnType') = 'void'
attr(`GeoDaWeight_GetNbrStats`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNbrStats`) = c("SWIGFunction", class('GeoDaWeight_GetNbrStats'))

# Start of GeoDaWeight_GetNbrSize

`GeoDaWeight_GetNbrSize` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_GetNbrSize', self, obs_idx, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetNbrSize`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNbrSize`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNbrSize`) = c("SWIGFunction", class('GeoDaWeight_GetNbrSize'))

# Start of GeoDaWeight_SpatialLag

`GeoDaWeight_SpatialLag` = function(self, obs_idx, data, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  data = as.numeric(data);
  ;.Call('R_swig_GeoDaWeight_SpatialLag', self, obs_idx, data, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_SpatialLag`, 'returnType') = 'numeric'
attr(`GeoDaWeight_SpatialLag`, "inputTypes") = c('_p_GeoDaWeight', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaWeight_SpatialLag`) = c("SWIGFunction", class('GeoDaWeight_SpatialLag'))

# Start of GeoDaWeight_SaveToFile

`GeoDaWeight_SaveToFile__SWIG_0` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(layer_name, "ExternalReference")) layer_name = slot(layer_name,"ref") 
  if (inherits(id_var_name, "ExternalReference")) id_var_name = slot(id_var_name,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveToFile__SWIG_0', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_SaveToFile__SWIG_0`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveToFile__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_wxString', '_p_wxString', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t')
class(`GeoDaWeight_SaveToFile__SWIG_0`) = c("SWIGFunction", class('GeoDaWeight_SaveToFile__SWIG_0'))

# Start of GeoDaWeight_SaveToFile

`GeoDaWeight_SaveToFile__SWIG_1` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(layer_name, "ExternalReference")) layer_name = slot(layer_name,"ref") 
  if (inherits(id_var_name, "ExternalReference")) id_var_name = slot(id_var_name,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveToFile__SWIG_1', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_SaveToFile__SWIG_1`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveToFile__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_wxString', '_p_wxString', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t')
class(`GeoDaWeight_SaveToFile__SWIG_1`) = c("SWIGFunction", class('GeoDaWeight_SaveToFile__SWIG_1'))

`GeoDaWeight_SaveToFile` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && extends(argtypes[2], '_p_wxString') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_wxString') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_wxString') && length(argv[[4]]) == 1 && extends(argtypes[5], '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t') && length(argv[[5]]) == 1) {
      f <- GeoDaWeight_SaveToFile__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && extends(argtypes[2], '_p_wxString') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_wxString') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_wxString') && length(argv[[4]]) == 1 && extends(argtypes[5], '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t') && length(argv[[5]]) == 1) {
      f <- GeoDaWeight_SaveToFile__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaWeight_SaveToFile with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaWeight_GetSparsity

`GeoDaWeight_GetSparsity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetSparsity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetSparsity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetSparsity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetSparsity`) = c("SWIGFunction", class('GeoDaWeight_GetSparsity'))

# Start of GeoDaWeight_GetDensity

`GeoDaWeight_GetDensity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetDensity', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetDensity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetDensity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetDensity`) = c("SWIGFunction", class('GeoDaWeight_GetDensity'))

# Start of GeoDaWeight_GetMinNumNbrs

`GeoDaWeight_GetMinNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMinNumNbrs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetMinNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMinNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMinNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMinNumNbrs'))

# Start of GeoDaWeight_GetMaxNumNbrs

`GeoDaWeight_GetMaxNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMaxNumNbrs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetMaxNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMaxNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMaxNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMaxNumNbrs'))

# Start of GeoDaWeight_GetMeanNumNbrs

`GeoDaWeight_GetMeanNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMeanNumNbrs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetMeanNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMeanNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMeanNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMeanNumNbrs'))

# Start of GeoDaWeight_GetMedianNumNbrs

`GeoDaWeight_GetMedianNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMedianNumNbrs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetMedianNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMedianNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMedianNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMedianNumNbrs'))

# Start of GeoDaWeight_GetNumObs

`GeoDaWeight_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNumObs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNumObs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNumObs`) = c("SWIGFunction", class('GeoDaWeight_GetNumObs'))

# Start of GeoDaWeight_IsInternalUse

`GeoDaWeight_IsInternalUse` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_IsInternalUse', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_IsInternalUse`, 'returnType') = 'logical'
attr(`GeoDaWeight_IsInternalUse`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_IsInternalUse`) = c("SWIGFunction", class('GeoDaWeight_IsInternalUse'))

# Start of GeoDaWeight_Equal

`GeoDaWeight_Equal` = function(self, gw, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(gw, "ExternalReference")) gw = slot(gw,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_Equal', self, gw, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_Equal`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDaWeight_Equal`, "inputTypes") = c('_p_GeoDaWeight', '_p_GeoDaWeight')
class(`GeoDaWeight_Equal`) = c("SWIGFunction", class('GeoDaWeight_Equal'))

# Start of GeoDaWeight_GetTitle

`GeoDaWeight_GetTitle` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_GetTitle', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetTitle`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_GetTitle`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetTitle`) = c("SWIGFunction", class('GeoDaWeight_GetTitle'))

# Start of GeoDaWeight_GetIDName

`GeoDaWeight_GetIDName` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_GetIDName', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetIDName`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_GetIDName`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetIDName`) = c("SWIGFunction", class('GeoDaWeight_GetIDName'))

# Start of GeoDaWeight_gal_type_get

`GeoDaWeight_gal_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gal_type_get', as.logical(.copy), PACKAGE='libgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gal_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gal_type_get`) = c("SWIGFunction", class('GeoDaWeight_gal_type_get'))

# Start of GeoDaWeight_gwt_type_get

`GeoDaWeight_gwt_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gwt_type_get', as.logical(.copy), PACKAGE='libgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gwt_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gwt_type_get`) = c("SWIGFunction", class('GeoDaWeight_gwt_type_get'))

# Start of GeoDaWeight_weight_type_set

`GeoDaWeight_weight_type_set` = function(self, s_weight_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_weight_type = enumToInteger(s_weight_type, "_GeoDaWeight__WeightType"); 
  
  if(length(s_weight_type) > 1) {
    warning("using only the first element of s_weight_type");
  };
  
  ;.Call('R_swig_GeoDaWeight_weight_type_set', self, s_weight_type, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_weight_type_set`, 'returnType') = 'void'
attr(`GeoDaWeight_weight_type_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_weight_type_set`) = c("SWIGFunction", class('GeoDaWeight_weight_type_set'))

# Start of GeoDaWeight_weight_type_get

`GeoDaWeight_weight_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_weight_type_get', self, as.logical(.copy), PACKAGE='libgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_weight_type_get`, 'returnType') = 'character'
attr(`GeoDaWeight_weight_type_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_weight_type_get`) = c("SWIGFunction", class('GeoDaWeight_weight_type_get'))

# Start of GeoDaWeight_wflnm_set

`GeoDaWeight_wflnm_set` = function(self, s_wflnm)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_wflnm, "ExternalReference")) s_wflnm = slot(s_wflnm,"ref") 
  ;.Call('R_swig_GeoDaWeight_wflnm_set', self, s_wflnm, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_wflnm_set`, 'returnType') = 'void'
attr(`GeoDaWeight_wflnm_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_wflnm_set`) = c("SWIGFunction", class('GeoDaWeight_wflnm_set'))

# Start of GeoDaWeight_wflnm_get

`GeoDaWeight_wflnm_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_wflnm_get', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_wflnm_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_wflnm_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_wflnm_get`) = c("SWIGFunction", class('GeoDaWeight_wflnm_get'))

# Start of GeoDaWeight_id_field_set

`GeoDaWeight_id_field_set` = function(self, s_id_field)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_id_field, "ExternalReference")) s_id_field = slot(s_id_field,"ref") 
  ;.Call('R_swig_GeoDaWeight_id_field_set', self, s_id_field, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_id_field_set`, 'returnType') = 'void'
attr(`GeoDaWeight_id_field_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_id_field_set`) = c("SWIGFunction", class('GeoDaWeight_id_field_set'))

# Start of GeoDaWeight_id_field_get

`GeoDaWeight_id_field_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_id_field_get', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_id_field_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_id_field_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_id_field_get`) = c("SWIGFunction", class('GeoDaWeight_id_field_get'))

# Start of GeoDaWeight_title_set

`GeoDaWeight_title_set` = function(self, s_title)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_title, "ExternalReference")) s_title = slot(s_title,"ref") 
  ;.Call('R_swig_GeoDaWeight_title_set', self, s_title, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_title_set`, 'returnType') = 'void'
attr(`GeoDaWeight_title_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_title_set`) = c("SWIGFunction", class('GeoDaWeight_title_set'))

# Start of GeoDaWeight_title_get

`GeoDaWeight_title_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_title_get', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_title_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_title_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_title_get`) = c("SWIGFunction", class('GeoDaWeight_title_get'))

# Start of GeoDaWeight_symmetry_checked_set

`GeoDaWeight_symmetry_checked_set` = function(self, s_symmetry_checked)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_symmetry_checked = as.logical(s_symmetry_checked);
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_set', self, s_symmetry_checked, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_set`, 'returnType') = 'void'
attr(`GeoDaWeight_symmetry_checked_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_symmetry_checked_set`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_set'))

# Start of GeoDaWeight_symmetry_checked_get

`GeoDaWeight_symmetry_checked_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_symmetry_checked_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_symmetry_checked_get`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_get'))

# Start of GeoDaWeight_is_symmetric_set

`GeoDaWeight_is_symmetric_set` = function(self, s_is_symmetric)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_symmetric = as.logical(s_is_symmetric);
  ;.Call('R_swig_GeoDaWeight_is_symmetric_set', self, s_is_symmetric, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_symmetric_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_symmetric_set`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_set'))

# Start of GeoDaWeight_is_symmetric_get

`GeoDaWeight_is_symmetric_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_symmetric_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_symmetric_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_symmetric_get`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_get'))

# Start of GeoDaWeight_num_obs_set

`GeoDaWeight_num_obs_set` = function(self, s_num_obs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_num_obs = as.integer(s_num_obs);
  
  if(length(s_num_obs) > 1) {
    warning("using only the first element of s_num_obs");
  };
  
  ;.Call('R_swig_GeoDaWeight_num_obs_set', self, s_num_obs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_num_obs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_num_obs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_num_obs_set`) = c("SWIGFunction", class('GeoDaWeight_num_obs_set'))

# Start of GeoDaWeight_num_obs_get

`GeoDaWeight_num_obs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_num_obs_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_num_obs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_num_obs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_num_obs_get`) = c("SWIGFunction", class('GeoDaWeight_num_obs_get'))

# Start of GeoDaWeight_sparsity_set

`GeoDaWeight_sparsity_set` = function(self, s_sparsity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_sparsity_set', self, s_sparsity, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_sparsity_set`, 'returnType') = 'void'
attr(`GeoDaWeight_sparsity_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_sparsity_set`) = c("SWIGFunction", class('GeoDaWeight_sparsity_set'))

# Start of GeoDaWeight_sparsity_get

`GeoDaWeight_sparsity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_sparsity_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_sparsity_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_sparsity_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_sparsity_get`) = c("SWIGFunction", class('GeoDaWeight_sparsity_get'))

# Start of GeoDaWeight_density_set

`GeoDaWeight_density_set` = function(self, s_density)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_density_set', self, s_density, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_density_set`, 'returnType') = 'void'
attr(`GeoDaWeight_density_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_density_set`) = c("SWIGFunction", class('GeoDaWeight_density_set'))

# Start of GeoDaWeight_density_get

`GeoDaWeight_density_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_density_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_density_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_density_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_density_get`) = c("SWIGFunction", class('GeoDaWeight_density_get'))

# Start of GeoDaWeight_min_nbrs_set

`GeoDaWeight_min_nbrs_set` = function(self, s_min_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_min_nbrs = as.integer(s_min_nbrs);
  
  if(length(s_min_nbrs) > 1) {
    warning("using only the first element of s_min_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_min_nbrs_set', self, s_min_nbrs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_min_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_min_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_set'))

# Start of GeoDaWeight_min_nbrs_get

`GeoDaWeight_min_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_min_nbrs_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_min_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_min_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_get'))

# Start of GeoDaWeight_max_nbrs_set

`GeoDaWeight_max_nbrs_set` = function(self, s_max_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_max_nbrs = as.integer(s_max_nbrs);
  
  if(length(s_max_nbrs) > 1) {
    warning("using only the first element of s_max_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_max_nbrs_set', self, s_max_nbrs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_max_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_max_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_set'))

# Start of GeoDaWeight_max_nbrs_get

`GeoDaWeight_max_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_max_nbrs_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_max_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_max_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_get'))

# Start of GeoDaWeight_mean_nbrs_set

`GeoDaWeight_mean_nbrs_set` = function(self, s_mean_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_set', self, s_mean_nbrs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_mean_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_mean_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_set'))

# Start of GeoDaWeight_mean_nbrs_get

`GeoDaWeight_mean_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_mean_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_mean_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_get'))

# Start of GeoDaWeight_median_nbrs_set

`GeoDaWeight_median_nbrs_set` = function(self, s_median_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_median_nbrs_set', self, s_median_nbrs, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_median_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_median_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_set'))

# Start of GeoDaWeight_median_nbrs_get

`GeoDaWeight_median_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_median_nbrs_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_median_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_median_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_get'))

# Start of GeoDaWeight_is_internal_use_set

`GeoDaWeight_is_internal_use_set` = function(self, s_is_internal_use)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_internal_use = as.logical(s_is_internal_use);
  ;.Call('R_swig_GeoDaWeight_is_internal_use_set', self, s_is_internal_use, PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_internal_use_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_internal_use_set`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_set'))

# Start of GeoDaWeight_is_internal_use_get

`GeoDaWeight_is_internal_use_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_internal_use_get', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_internal_use_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_internal_use_get`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_get'))

# Start of accessor method for GeoDaWeight
setMethod('$', '_p_GeoDaWeight', function(x, name)

{
  accessorFuns = list('SaveDIDWeights' = GeoDaWeight_SaveDIDWeights, 'SaveSpaceTimeWeights' = GeoDaWeight_SaveSpaceTimeWeights, 'CheckNeighbor' = GeoDaWeight_CheckNeighbor, 'GetNeighbors' = GeoDaWeight_GetNeighbors, 'Update' = GeoDaWeight_Update, 'HasIsolates' = GeoDaWeight_HasIsolates, 'GetNbrStats' = GeoDaWeight_GetNbrStats, 'GetNbrSize' = GeoDaWeight_GetNbrSize, 'SpatialLag' = GeoDaWeight_SpatialLag, 'SaveToFile' = GeoDaWeight_SaveToFile, 'GetSparsity' = GeoDaWeight_GetSparsity, 'GetDensity' = GeoDaWeight_GetDensity, 'GetMinNumNbrs' = GeoDaWeight_GetMinNumNbrs, 'GetMaxNumNbrs' = GeoDaWeight_GetMaxNumNbrs, 'GetMeanNumNbrs' = GeoDaWeight_GetMeanNumNbrs, 'GetMedianNumNbrs' = GeoDaWeight_GetMedianNumNbrs, 'GetNumObs' = GeoDaWeight_GetNumObs, 'IsInternalUse' = GeoDaWeight_IsInternalUse, 'Equal' = GeoDaWeight_Equal, 'GetTitle' = GeoDaWeight_GetTitle, 'GetIDName' = GeoDaWeight_GetIDName, 'weight_type' = GeoDaWeight_weight_type_get, 'wflnm' = GeoDaWeight_wflnm_get, 'id_field' = GeoDaWeight_id_field_get, 'title' = GeoDaWeight_title_get, 'symmetry_checked' = GeoDaWeight_symmetry_checked_get, 'is_symmetric' = GeoDaWeight_is_symmetric_get, 'num_obs' = GeoDaWeight_num_obs_get, 'sparsity' = GeoDaWeight_sparsity_get, 'density' = GeoDaWeight_density_get, 'min_nbrs' = GeoDaWeight_min_nbrs_get, 'max_nbrs' = GeoDaWeight_max_nbrs_get, 'mean_nbrs' = GeoDaWeight_mean_nbrs_get, 'median_nbrs' = GeoDaWeight_median_nbrs_get, 'is_internal_use' = GeoDaWeight_is_internal_use_get);
  vaccessors = c('weight_type', 'wflnm', 'id_field', 'title', 'symmetry_checked', 'is_symmetric', 'num_obs', 'sparsity', 'density', 'min_nbrs', 'max_nbrs', 'mean_nbrs', 'median_nbrs', 'is_internal_use');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaWeight
# Start of accessor method for GeoDaWeight
setMethod('$<-', '_p_GeoDaWeight', function(x, name, value)

{
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaWeight', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaWeight
setMethod('delete', '_p_GeoDaWeight', function(obj) {delete_GeoDaWeight(obj)})
# Start of delete_AbstractLocalSA

`delete_AbstractLocalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_AbstractLocalSA', self, PACKAGE='libgeoda');
  
}

attr(`delete_AbstractLocalSA`, 'returnType') = 'void'
attr(`delete_AbstractLocalSA`, "inputTypes") = c('_p_AbstractLocalSA')
class(`delete_AbstractLocalSA`) = c("SWIGFunction", class('delete_AbstractLocalSA'))

# Start of AbstractLocalSA_ComputeLoalSA

`AbstractLocalSA_ComputeLoalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_ComputeLoalSA', self, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_ComputeLoalSA`, 'returnType') = 'void'
attr(`AbstractLocalSA_ComputeLoalSA`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_ComputeLoalSA`) = c("SWIGFunction", class('AbstractLocalSA_ComputeLoalSA'))

# Start of AbstractLocalSA_CalcPseudoP

`AbstractLocalSA_CalcPseudoP` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP', self, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_CalcPseudoP`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP'))

# Start of AbstractLocalSA_CalcPseudoP_threaded

`AbstractLocalSA_CalcPseudoP_threaded` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP_threaded', self, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP_threaded`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP_threaded`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_CalcPseudoP_threaded`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP_threaded'))

# Start of AbstractLocalSA_CalcPseudoP_range

`AbstractLocalSA_CalcPseudoP_range` = function(self, obs_start, obs_end, seed_start)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_start = as.integer(obs_start);
  
  if(length(obs_start) > 1) {
    warning("using only the first element of obs_start");
  };
  
  obs_end = as.integer(obs_end);
  
  if(length(obs_end) > 1) {
    warning("using only the first element of obs_end");
  };
  
  if (inherits(seed_start, "ExternalReference")) seed_start = slot(seed_start,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP_range', self, obs_start, obs_end, seed_start, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP_range`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP_range`, "inputTypes") = c('_p_AbstractLocalSA', 'integer', 'integer', '_p_uint64_t')
class(`AbstractLocalSA_CalcPseudoP_range`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP_range'))

# Start of AbstractLocalSA_LargerPermLocalSA

`AbstractLocalSA_LargerPermLocalSA` = function(self, cnt, permNeighbors, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  permNeighbors = as.integer(permNeighbors);
  ;.Call('R_swig_AbstractLocalSA_LargerPermLocalSA', self, cnt, permNeighbors, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_LargerPermLocalSA`, 'returnType') = 'logical'
attr(`AbstractLocalSA_LargerPermLocalSA`, "inputTypes") = c('_p_AbstractLocalSA', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`AbstractLocalSA_LargerPermLocalSA`) = c("SWIGFunction", class('AbstractLocalSA_LargerPermLocalSA'))

# Start of AbstractLocalSA_Run

`AbstractLocalSA_Run` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_Run', self, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_Run`, 'returnType') = 'void'
attr(`AbstractLocalSA_Run`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_Run`) = c("SWIGFunction", class('AbstractLocalSA_Run'))

# Start of AbstractLocalSA_SetSignificanceFilter

`AbstractLocalSA_SetSignificanceFilter` = function(self, filter_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filter_id = as.integer(filter_id);
  
  if(length(filter_id) > 1) {
    warning("using only the first element of filter_id");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetSignificanceFilter', self, filter_id, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetSignificanceFilter`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetSignificanceFilter`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetSignificanceFilter`) = c("SWIGFunction", class('AbstractLocalSA_SetSignificanceFilter'))

# Start of AbstractLocalSA_GetSignificanceFilter

`AbstractLocalSA_GetSignificanceFilter` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSignificanceFilter', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetSignificanceFilter`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetSignificanceFilter`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSignificanceFilter`) = c("SWIGFunction", class('AbstractLocalSA_GetSignificanceFilter'))

# Start of AbstractLocalSA_GetSignificanceCutoff

`AbstractLocalSA_GetSignificanceCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSignificanceCutoff', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetSignificanceCutoff`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetSignificanceCutoff`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSignificanceCutoff`) = c("SWIGFunction", class('AbstractLocalSA_GetSignificanceCutoff'))

# Start of AbstractLocalSA_SetSignificanceCutoff

`AbstractLocalSA_SetSignificanceCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetSignificanceCutoff', self, val, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetSignificanceCutoff`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetSignificanceCutoff`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetSignificanceCutoff`) = c("SWIGFunction", class('AbstractLocalSA_SetSignificanceCutoff'))

# Start of AbstractLocalSA_GetUserCutoff

`AbstractLocalSA_GetUserCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetUserCutoff', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetUserCutoff`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetUserCutoff`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetUserCutoff`) = c("SWIGFunction", class('AbstractLocalSA_GetUserCutoff'))

# Start of AbstractLocalSA_SetUserCutoff

`AbstractLocalSA_SetUserCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetUserCutoff', self, val, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetUserCutoff`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetUserCutoff`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetUserCutoff`) = c("SWIGFunction", class('AbstractLocalSA_SetUserCutoff'))

# Start of AbstractLocalSA_GetBO

`AbstractLocalSA_GetBO` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetBO', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetBO`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetBO`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetBO`) = c("SWIGFunction", class('AbstractLocalSA_GetBO'))

# Start of AbstractLocalSA_SetBO

`AbstractLocalSA_SetBO` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetBO', self, val, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetBO`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetBO`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetBO`) = c("SWIGFunction", class('AbstractLocalSA_SetBO'))

# Start of AbstractLocalSA_GetFDR

`AbstractLocalSA_GetFDR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetFDR', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetFDR`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetFDR`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetFDR`) = c("SWIGFunction", class('AbstractLocalSA_GetFDR'))

# Start of AbstractLocalSA_SetFDR

`AbstractLocalSA_SetFDR` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetFDR', self, val, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetFDR`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetFDR`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetFDR`) = c("SWIGFunction", class('AbstractLocalSA_SetFDR'))

# Start of AbstractLocalSA_GetNumPermutations

`AbstractLocalSA_GetNumPermutations` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetNumPermutations', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetNumPermutations`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetNumPermutations`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetNumPermutations`) = c("SWIGFunction", class('AbstractLocalSA_GetNumPermutations'))

# Start of AbstractLocalSA_SetNumPermutations

`AbstractLocalSA_SetNumPermutations` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetNumPermutations', self, val, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetNumPermutations`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetNumPermutations`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetNumPermutations`) = c("SWIGFunction", class('AbstractLocalSA_SetNumPermutations'))

# Start of AbstractLocalSA_GetLastUsedSeed

`AbstractLocalSA_GetLastUsedSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractLocalSA_GetLastUsedSeed', self, as.logical(.copy), PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_uint64_t", ref=ans);
  
  ans
  
}

attr(`AbstractLocalSA_GetLastUsedSeed`, 'returnType') = '_p_uint64_t'
attr(`AbstractLocalSA_GetLastUsedSeed`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetLastUsedSeed`) = c("SWIGFunction", class('AbstractLocalSA_GetLastUsedSeed'))

# Start of AbstractLocalSA_SetLastUsedSeed

`AbstractLocalSA_SetLastUsedSeed` = function(self, seed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(seed, "ExternalReference")) seed = slot(seed,"ref") 
  ;.Call('R_swig_AbstractLocalSA_SetLastUsedSeed', self, seed, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetLastUsedSeed`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetLastUsedSeed`, "inputTypes") = c('_p_AbstractLocalSA', '_p_uint64_t')
class(`AbstractLocalSA_SetLastUsedSeed`) = c("SWIGFunction", class('AbstractLocalSA_SetLastUsedSeed'))

# Start of AbstractLocalSA_IsReuseLastSeed

`AbstractLocalSA_IsReuseLastSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_IsReuseLastSeed', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_IsReuseLastSeed`, 'returnType') = 'logical'
attr(`AbstractLocalSA_IsReuseLastSeed`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_IsReuseLastSeed`) = c("SWIGFunction", class('AbstractLocalSA_IsReuseLastSeed'))

# Start of AbstractLocalSA_SetReuseLastSeed

`AbstractLocalSA_SetReuseLastSeed` = function(self, reuse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  reuse = as.logical(reuse);
  ;.Call('R_swig_AbstractLocalSA_SetReuseLastSeed', self, reuse, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetReuseLastSeed`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetReuseLastSeed`, "inputTypes") = c('_p_AbstractLocalSA', 'logical')
class(`AbstractLocalSA_SetReuseLastSeed`) = c("SWIGFunction", class('AbstractLocalSA_SetReuseLastSeed'))

# Start of AbstractLocalSA_GetHasIsolates

`AbstractLocalSA_GetHasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetHasIsolates', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetHasIsolates`, 'returnType') = 'logical'
attr(`AbstractLocalSA_GetHasIsolates`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetHasIsolates`) = c("SWIGFunction", class('AbstractLocalSA_GetHasIsolates'))

# Start of AbstractLocalSA_GetHasUndefined

`AbstractLocalSA_GetHasUndefined` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetHasUndefined', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetHasUndefined`, 'returnType') = 'logical'
attr(`AbstractLocalSA_GetHasUndefined`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetHasUndefined`) = c("SWIGFunction", class('AbstractLocalSA_GetHasUndefined'))

# Start of AbstractLocalSA_GetDefaultCategories

`AbstractLocalSA_GetDefaultCategories` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetDefaultCategories', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetDefaultCategories`, 'returnType') = 'character'
attr(`AbstractLocalSA_GetDefaultCategories`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetDefaultCategories`) = c("SWIGFunction", class('AbstractLocalSA_GetDefaultCategories'))

# Start of AbstractLocalSA_GetDefaultCutoffs

`AbstractLocalSA_GetDefaultCutoffs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetDefaultCutoffs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetDefaultCutoffs`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetDefaultCutoffs`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetDefaultCutoffs`) = c("SWIGFunction", class('AbstractLocalSA_GetDefaultCutoffs'))

# Start of AbstractLocalSA_GetLocalSignificanceValues

`AbstractLocalSA_GetLocalSignificanceValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetLocalSignificanceValues', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetLocalSignificanceValues`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetLocalSignificanceValues`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetLocalSignificanceValues`) = c("SWIGFunction", class('AbstractLocalSA_GetLocalSignificanceValues'))

# Start of AbstractLocalSA_GetClusterIndicators

`AbstractLocalSA_GetClusterIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetClusterIndicators', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetClusterIndicators`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetClusterIndicators`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetClusterIndicators`) = c("SWIGFunction", class('AbstractLocalSA_GetClusterIndicators'))

# Start of AbstractLocalSA_GetSigCatIndicators

`AbstractLocalSA_GetSigCatIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSigCatIndicators', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetSigCatIndicators`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetSigCatIndicators`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSigCatIndicators`) = c("SWIGFunction", class('AbstractLocalSA_GetSigCatIndicators'))

# Start of AbstractLocalSA_IsRowStandardize

`AbstractLocalSA_IsRowStandardize` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_IsRowStandardize', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_IsRowStandardize`, 'returnType') = 'logical'
attr(`AbstractLocalSA_IsRowStandardize`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_IsRowStandardize`) = c("SWIGFunction", class('AbstractLocalSA_IsRowStandardize'))

# Start of AbstractLocalSA_SetRowStandardize

`AbstractLocalSA_SetRowStandardize` = function(self, rowStandardize)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  rowStandardize = as.logical(rowStandardize);
  ;.Call('R_swig_AbstractLocalSA_SetRowStandardize', self, rowStandardize, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetRowStandardize`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetRowStandardize`, "inputTypes") = c('_p_AbstractLocalSA', 'logical')
class(`AbstractLocalSA_SetRowStandardize`) = c("SWIGFunction", class('AbstractLocalSA_SetRowStandardize'))

# Start of AbstractLocalSA_GetNumThreads

`AbstractLocalSA_GetNumThreads` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetNumThreads', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_GetNumThreads`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetNumThreads`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetNumThreads`) = c("SWIGFunction", class('AbstractLocalSA_GetNumThreads'))

# Start of AbstractLocalSA_SetNumThreads

`AbstractLocalSA_SetNumThreads` = function(self, n_threads)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n_threads = as.integer(n_threads);
  
  if(length(n_threads) > 1) {
    warning("using only the first element of n_threads");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetNumThreads', self, n_threads, PACKAGE='libgeoda');
  
}

attr(`AbstractLocalSA_SetNumThreads`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetNumThreads`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetNumThreads`) = c("SWIGFunction", class('AbstractLocalSA_SetNumThreads'))

# Start of accessor method for AbstractLocalSA
setMethod('$', '_p_AbstractLocalSA', function(x, name)

{
  accessorFuns = list('ComputeLoalSA' = AbstractLocalSA_ComputeLoalSA, 'CalcPseudoP' = AbstractLocalSA_CalcPseudoP, 'CalcPseudoP_threaded' = AbstractLocalSA_CalcPseudoP_threaded, 'CalcPseudoP_range' = AbstractLocalSA_CalcPseudoP_range, 'LargerPermLocalSA' = AbstractLocalSA_LargerPermLocalSA, 'Run' = AbstractLocalSA_Run, 'SetSignificanceFilter' = AbstractLocalSA_SetSignificanceFilter, 'GetSignificanceFilter' = AbstractLocalSA_GetSignificanceFilter, 'GetSignificanceCutoff' = AbstractLocalSA_GetSignificanceCutoff, 'SetSignificanceCutoff' = AbstractLocalSA_SetSignificanceCutoff, 'GetUserCutoff' = AbstractLocalSA_GetUserCutoff, 'SetUserCutoff' = AbstractLocalSA_SetUserCutoff, 'GetBO' = AbstractLocalSA_GetBO, 'SetBO' = AbstractLocalSA_SetBO, 'GetFDR' = AbstractLocalSA_GetFDR, 'SetFDR' = AbstractLocalSA_SetFDR, 'GetNumPermutations' = AbstractLocalSA_GetNumPermutations, 'SetNumPermutations' = AbstractLocalSA_SetNumPermutations, 'GetLastUsedSeed' = AbstractLocalSA_GetLastUsedSeed, 'SetLastUsedSeed' = AbstractLocalSA_SetLastUsedSeed, 'IsReuseLastSeed' = AbstractLocalSA_IsReuseLastSeed, 'SetReuseLastSeed' = AbstractLocalSA_SetReuseLastSeed, 'GetHasIsolates' = AbstractLocalSA_GetHasIsolates, 'GetHasUndefined' = AbstractLocalSA_GetHasUndefined, 'GetDefaultCategories' = AbstractLocalSA_GetDefaultCategories, 'GetDefaultCutoffs' = AbstractLocalSA_GetDefaultCutoffs, 'GetLocalSignificanceValues' = AbstractLocalSA_GetLocalSignificanceValues, 'GetClusterIndicators' = AbstractLocalSA_GetClusterIndicators, 'GetSigCatIndicators' = AbstractLocalSA_GetSigCatIndicators, 'IsRowStandardize' = AbstractLocalSA_IsRowStandardize, 'SetRowStandardize' = AbstractLocalSA_SetRowStandardize, 'GetNumThreads' = AbstractLocalSA_GetNumThreads, 'SetNumThreads' = AbstractLocalSA_SetNumThreads);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for AbstractLocalSA
setMethod('delete', '_p_AbstractLocalSA', function(obj) {delete_AbstractLocalSA(obj)})
# Start of new_UniLisa

`UniLisa` = function(num_obs, data, undefs, w)
{
  num_obs = as.integer(num_obs);
  
  if(length(num_obs) > 1) {
    warning("using only the first element of num_obs");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  ;ans = .Call('R_swig_new_UniLisa', num_obs, data, undefs, w, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  reg.finalizer(ans@ref, delete_UniLisa)
  ans
  
}

attr(`UniLisa`, 'returnType') = '_p_UniLisa'
attr(`UniLisa`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', '_p_GeoDaWeight')
class(`UniLisa`) = c("SWIGFunction", class('UniLisa'))

# Start of delete_UniLisa

`delete_UniLisa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_UniLisa', self, PACKAGE='libgeoda');
  
}

attr(`delete_UniLisa`, 'returnType') = 'void'
attr(`delete_UniLisa`, "inputTypes") = c('_p_UniLisa')
class(`delete_UniLisa`) = c("SWIGFunction", class('delete_UniLisa'))

# Start of UniLisa_ComputeLoalSA

`UniLisa_ComputeLoalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_ComputeLoalSA', self, PACKAGE='libgeoda');
  
}

attr(`UniLisa_ComputeLoalSA`, 'returnType') = 'void'
attr(`UniLisa_ComputeLoalSA`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_ComputeLoalSA`) = c("SWIGFunction", class('UniLisa_ComputeLoalSA'))

# Start of UniLisa_LargerPermLocalSA

`UniLisa_LargerPermLocalSA` = function(self, cnt, permNeighbors, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  permNeighbors = as.integer(permNeighbors);
  ;.Call('R_swig_UniLisa_LargerPermLocalSA', self, cnt, permNeighbors, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`UniLisa_LargerPermLocalSA`, 'returnType') = 'logical'
attr(`UniLisa_LargerPermLocalSA`, "inputTypes") = c('_p_UniLisa', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`UniLisa_LargerPermLocalSA`) = c("SWIGFunction", class('UniLisa_LargerPermLocalSA'))

# Start of UniLisa_GetClusterIndicators

`UniLisa_GetClusterIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetClusterIndicators', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`UniLisa_GetClusterIndicators`, 'returnType') = 'integer'
attr(`UniLisa_GetClusterIndicators`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetClusterIndicators`) = c("SWIGFunction", class('UniLisa_GetClusterIndicators'))

# Start of UniLisa_GetLagValues

`UniLisa_GetLagValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetLagValues', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`UniLisa_GetLagValues`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`UniLisa_GetLagValues`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetLagValues`) = c("SWIGFunction", class('UniLisa_GetLagValues'))

# Start of UniLisa_GetLocalMoranValues

`UniLisa_GetLocalMoranValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetLocalMoranValues', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`UniLisa_GetLocalMoranValues`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`UniLisa_GetLocalMoranValues`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetLocalMoranValues`) = c("SWIGFunction", class('UniLisa_GetLocalMoranValues'))

# Start of accessor method for UniLisa
setMethod('$', '_p_UniLisa', function(x, name)

{
  accessorFuns = list('ComputeLoalSA' = UniLisa_ComputeLoalSA, 'LargerPermLocalSA' = UniLisa_LargerPermLocalSA, 'GetClusterIndicators' = UniLisa_GetClusterIndicators, 'GetLagValues' = UniLisa_GetLagValues, 'GetLocalMoranValues' = UniLisa_GetLocalMoranValues);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for UniLisa
setMethod('delete', '_p_UniLisa', function(obj) {delete_UniLisa(obj)})
# Start of new_GeoDa

`GeoDa__SWIG_0` = function(layer_name)
{
  layer_name = as(layer_name, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_0', layer_name, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_0`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_0`, "inputTypes") = c('character')
class(`GeoDa__SWIG_0`) = c("SWIGFunction", class('GeoDa__SWIG_0'))

# Start of new_GeoDa

`GeoDa__SWIG_1` = function(pDsPath)
{
  pDsPath = as(pDsPath, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_1', pDsPath, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_1`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_1`, "inputTypes") = c('character')
class(`GeoDa__SWIG_1`) = c("SWIGFunction", class('GeoDa__SWIG_1'))

`GeoDa` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- GeoDa__SWIG_0; 
    }
    else if (is.character(argv[[1]])) {
      f <- GeoDa__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GeoDa

`delete_GeoDa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDa', self, PACKAGE='libgeoda');
  
}

attr(`delete_GeoDa`, 'returnType') = 'void'
attr(`delete_GeoDa`, "inputTypes") = c('_p_GeoDa')
class(`delete_GeoDa`) = c("SWIGFunction", class('delete_GeoDa'))

# Start of GeoDa_GetNumObs

`GeoDa_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumObs', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDa_GetNumObs`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumObs`) = c("SWIGFunction", class('GeoDa_GetNumObs'))

# Start of GeoDa_GetNumCols

`GeoDa_GetNumCols` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumCols', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetNumCols`, 'returnType') = 'integer'
attr(`GeoDa_GetNumCols`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumCols`) = c("SWIGFunction", class('GeoDa_GetNumCols'))

# Start of GeoDa_GetFieldTypes

`GeoDa_GetFieldTypes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldTypes', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetFieldTypes`, 'returnType') = 'character'
attr(`GeoDa_GetFieldTypes`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldTypes`) = c("SWIGFunction", class('GeoDa_GetFieldTypes'))

# Start of GeoDa_GetFieldNames

`GeoDa_GetFieldNames` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldNames', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetFieldNames`, 'returnType') = 'character'
attr(`GeoDa_GetFieldNames`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldNames`) = c("SWIGFunction", class('GeoDa_GetFieldNames'))

# Start of GeoDa_GetNumericCol

`GeoDa_GetNumericCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetNumericCol', self, col_name, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetNumericCol`, 'returnType') = 'numeric'
attr(`GeoDa_GetNumericCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetNumericCol`) = c("SWIGFunction", class('GeoDa_GetNumericCol'))

# Start of GeoDa_GeIntegerCol

`GeoDa_GeIntegerCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GeIntegerCol', self, col_name, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GeIntegerCol`, 'returnType') = 'integer'
attr(`GeoDa_GeIntegerCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GeIntegerCol`) = c("SWIGFunction", class('GeoDa_GeIntegerCol'))

# Start of GeoDa_GetStringCol

`GeoDa_GetStringCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetStringCol', self, col_name, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetStringCol`, 'returnType') = 'character'
attr(`GeoDa_GetStringCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetStringCol`) = c("SWIGFunction", class('GeoDa_GetStringCol'))

# Start of GeoDa_GetUndefinesCol

`GeoDa_GetUndefinesCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetUndefinesCol', self, col_name, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetUndefinesCol`, 'returnType') = 'logical'
attr(`GeoDa_GetUndefinesCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetUndefinesCol`) = c("SWIGFunction", class('GeoDa_GetUndefinesCol'))

# Start of GeoDa_GetName

`GeoDa_GetName` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetName', self, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_GetName`, 'returnType') = 'character'
attr(`GeoDa_GetName`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetName`) = c("SWIGFunction", class('GeoDa_GetName'))

# Start of GeoDa_CreateQueenWeights

`GeoDa_CreateQueenWeights__SWIG_0` = function(self, polyid, order, include_lower_order)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  polyid = as(polyid, "character"); 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  ;ans = .Call('R_swig_GeoDa_CreateQueenWeights__SWIG_0', self, polyid, order, include_lower_order, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateQueenWeights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateQueenWeights__SWIG_0`, "inputTypes") = c('_p_GeoDa', 'character', 'integer', 'logical')
class(`GeoDa_CreateQueenWeights__SWIG_0`) = c("SWIGFunction", class('GeoDa_CreateQueenWeights__SWIG_0'))

# Start of GeoDa_CreateQueenWeights

`GeoDa_CreateQueenWeights__SWIG_1` = function(self, polyid, order)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  polyid = as(polyid, "character"); 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  ;ans = .Call('R_swig_GeoDa_CreateQueenWeights__SWIG_1', self, polyid, order, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateQueenWeights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateQueenWeights__SWIG_1`, "inputTypes") = c('_p_GeoDa', 'character', 'integer')
class(`GeoDa_CreateQueenWeights__SWIG_1`) = c("SWIGFunction", class('GeoDa_CreateQueenWeights__SWIG_1'))

# Start of GeoDa_CreateQueenWeights

`GeoDa_CreateQueenWeights__SWIG_2` = function(self, polyid)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  polyid = as(polyid, "character"); 
  ;ans = .Call('R_swig_GeoDa_CreateQueenWeights__SWIG_2', self, polyid, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateQueenWeights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateQueenWeights__SWIG_2`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_CreateQueenWeights__SWIG_2`) = c("SWIGFunction", class('GeoDa_CreateQueenWeights__SWIG_2'))

# Start of GeoDa_CreateQueenWeights

`GeoDa_CreateQueenWeights__SWIG_3` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_CreateQueenWeights__SWIG_3', self, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateQueenWeights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateQueenWeights__SWIG_3`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_CreateQueenWeights__SWIG_3`) = c("SWIGFunction", class('GeoDa_CreateQueenWeights__SWIG_3'))

`GeoDa_CreateQueenWeights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]]))) {
      f <- GeoDa_CreateQueenWeights__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- GeoDa_CreateQueenWeights__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- GeoDa_CreateQueenWeights__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- GeoDa_CreateQueenWeights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_CreateQueenWeights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDa_LISA

`GeoDa_LISA__SWIG_0` = function(self, w, data, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_GeoDa_LISA__SWIG_0', self, w, data, undefs, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  ans
  
}

attr(`GeoDa_LISA__SWIG_0`, 'returnType') = '_p_UniLisa'
attr(`GeoDa_LISA__SWIG_0`, "inputTypes") = c('_p_GeoDa', '_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDa_LISA__SWIG_0`) = c("SWIGFunction", class('GeoDa_LISA__SWIG_0'))

# Start of GeoDa_LISA

`GeoDa_LISA__SWIG_1` = function(self, w, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_GeoDa_LISA__SWIG_1', self, w, data, PACKAGE='libgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  ans
  
}

attr(`GeoDa_LISA__SWIG_1`, 'returnType') = '_p_UniLisa'
attr(`GeoDa_LISA__SWIG_1`, "inputTypes") = c('_p_GeoDa', '_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDa_LISA__SWIG_1`) = c("SWIGFunction", class('GeoDa_LISA__SWIG_1'))

`GeoDa_LISA` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.numeric(argv[[3]]) )) {
      f <- GeoDa_LISA__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.numeric(argv[[3]]) ) && ( is.logical(argv[[4]]) )) {
      f <- GeoDa_LISA__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_LISA with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_0` = function(self, k, w, col_names, distance_method, control_varible, control_threshold, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  
  ;.Call('R_swig_GeoDa_SKATER__SWIG_0', self, k, w, col_names, distance_method, control_varible, control_threshold, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_0`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_0`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character', 'character', 'numeric')
class(`GeoDa_SKATER__SWIG_0`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_0'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_1` = function(self, k, w, col_names, distance_method, control_varible, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_1', self, k, w, col_names, distance_method, control_varible, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_1`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_1`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character', 'character')
class(`GeoDa_SKATER__SWIG_1`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_1'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_2` = function(self, k, w, col_names, distance_method, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_2', self, k, w, col_names, distance_method, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_2`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_2`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character')
class(`GeoDa_SKATER__SWIG_2`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_2'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_3` = function(self, k, w, col_names, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  ;.Call('R_swig_GeoDa_SKATER__SWIG_3', self, k, w, col_names, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_3`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_3`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character')
class(`GeoDa_SKATER__SWIG_3`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_3'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_4` = function(self, k, w, data, distance_method, control_varible, control_threshold, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  
  ;.Call('R_swig_GeoDa_SKATER__SWIG_4', self, k, w, data, distance_method, control_varible, control_threshold, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_4`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_4`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character', 'character', 'numeric')
class(`GeoDa_SKATER__SWIG_4`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_4'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_5` = function(self, k, w, data, distance_method, control_varible, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_5', self, k, w, data, distance_method, control_varible, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_5`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_5`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character', 'character')
class(`GeoDa_SKATER__SWIG_5`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_5'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_6` = function(self, k, w, data, distance_method, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_6', self, k, w, data, distance_method, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_6`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_6`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character')
class(`GeoDa_SKATER__SWIG_6`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_6'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_7` = function(self, k, w, data, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;.Call('R_swig_GeoDa_SKATER__SWIG_7', self, k, w, data, as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_7`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_7`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list')
class(`GeoDa_SKATER__SWIG_7`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_7'))

`GeoDa_SKATER` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) )) {
      f <- GeoDa_SKATER__SWIG_7; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) )) {
      f <- GeoDa_SKATER__SWIG_3; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- GeoDa_SKATER__SWIG_6; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- GeoDa_SKATER__SWIG_2; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa_SKATER__SWIG_5; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa_SKATER__SWIG_1; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1 && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- GeoDa_SKATER__SWIG_4; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1 && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- GeoDa_SKATER__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_SKATER with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for GeoDa
setMethod('$', '_p_GeoDa', function(x, name)

{
  accessorFuns = list('GetNumObs' = GeoDa_GetNumObs, 'GetNumCols' = GeoDa_GetNumCols, 'GetFieldTypes' = GeoDa_GetFieldTypes, 'GetFieldNames' = GeoDa_GetFieldNames, 'GetNumericCol' = GeoDa_GetNumericCol, 'GeIntegerCol' = GeoDa_GeIntegerCol, 'GetStringCol' = GeoDa_GetStringCol, 'GetUndefinesCol' = GeoDa_GetUndefinesCol, 'GetName' = GeoDa_GetName, 'CreateQueenWeights' = GeoDa_CreateQueenWeights, 'LISA' = GeoDa_LISA, 'SKATER' = GeoDa_SKATER);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for GeoDa
setMethod('delete', '_p_GeoDa', function(obj) {delete_GeoDa(obj)})
# Start of test

`test` = function(.copy = FALSE)
{
  ;.Call('R_swig_test', as.logical(.copy), PACKAGE='libgeoda');
  
}

attr(`test`, 'returnType') = 'integer'
class(`test`) = c("SWIGFunction", class('test'))


defineEnumeration("_GeoDaWeight__WeightType",
 .values=c("gal_type" = .Call('R_swig_GeoDaWeight_gal_type_get',FALSE, PACKAGE='libgeoda'),
"gwt_type" = .Call('R_swig_GeoDaWeight_gwt_type_get',FALSE, PACKAGE='libgeoda')))


